---
layout: post
title: SQL 레벨업 - 5장. 반복문
tags: [SQL, SqlLvUp, UF]
permalink: /docs/SQL/SqlLvUp_5
date: 2023-07-22 23:48:00
---
# 반복문
## 반복문 의존증
- SQL에는 반복문이 없음
- SQL을 적용하기 힘든 작업에 무리하게 SQL을 사용할 필요는 없음
- 미들웨어 또는 O/R 맵퍼 등의 프레임워크가 내부적으로 반복계 코드를 사용하기도 함
- 반복문 의존증 예시
  - 온라인 처리에서 레코드 하나씩 접근하는 SELECT 구문을 반복 사용
  - 배치 처리에서 레코드를 하나씩 호스트 언어에서 처리하고 테이블에 갱신
## 반복계의 공포
### 반복계의 단점
- SQL 실행의 오버헤드
  - 전처리
    1. SQL 구문을 네트워크로 전송
    2. 데이터베이스 연결
    3. SQL 구문 파스
    4. SQL 구문의 실행 계획 생성 또는 평가
  - 후처리
    5. 결과 집합을 네트워크로 전송
  - 1, 5는 오버헤드 중 영향이 적음
  - 2는 커넥션 풀을 사용하여 오버헤드를 줄임
  - 3, 4는 오버헤드 중 가장 영향이 큼
  - 반복계를 사용할 경우 3이 반복되기 때문에 오버헤드가 높아짐
- 병렬 분산이 어려움
  - 반복계에서 실행하는 SQL 구문은 대부분 단순해서 1회의 구문이 접근하는 데이터양이 적음 → I/O 병렬화가 어려움
- 데이터베이스의 진화로 인한 혜택을 받을 수 없음
  - 가벼운 처리를 하는 반복계 구문은 미들웨어 또는 하드웨어 진화에 따른 혜택을 받을 수 없음
### 반복계를 빠르게 만드는 방법은 없을까?
- 반복계를 포장계로 다시 작성 → 실제 상황에서는 사용하기 어려움
- 각각의 SQL 을 빠르게 수정 → 각각의 구문이 간단하여 튜닝의 여지가 없음
- 다중화 처리 → 데이터를 분할할 수 있는 명확한 키가 없거나, 순서가 중요하거나, 병렬화했을 때 물리 리소스가 부족하면 사용할 수 없음
### 반복계의 장점
- 실행 계획의 안정성 → 실행 계획의 변동 위험이 거의 없음
- 예상 처리 시간의 정밀도
- 트랜잭션 제어가 편리 → 중간에 오류 발생 시 발생 구간에서 다시 처리 가능
## SQL에서는 반복을 어떻게 표현할까?
### 포인트는 CASE 식과 윈도우 함수
- SQL에서는 CASE 식과 윈도우 함수로 반복을 대신함
```sql
INSERT INTO Sales2
SELECT company,
       year,
       sale,
       CASE SIGN(sale - MAX(sale))
                           OVER ( PARTITION BY company
                                  ORDER BY year
                                  ROWS BETWEEN 1 PRECEDING
                                           AND 1 PRECEDING) )
       WHEN 0 THEN '='
       WHEN 1 THEN '+'
       WHEN -1 THEN '-'
       ELSE NULL END AS var
FROM Sales
```
- SIGN 함수는 숫자를 매개변수로 받아 음수라면 -1, 양수라면 1, 0이라면 0을 리턴
- 위의 구문은 결합을 사용하지 않기 때문에 테이블의 레코드 수가 증가해도 실행 계획에 영향을 주지 않아 안정적
- 윈도우 함수에 `ROWS BETWEEN` 옵션을 사용하여 레코드 범위를 제한
  - 상관 서브쿼리를 사용할 경우 실행 계획이 복잡해지므로 성능적인 리스크 발생
  - 상관 쿼리는 MAX/MIN을 사용하므로 두 번째, 세 번째 데이터를 구하기 어려움
### 최대 반복 횟수가 정해진 경우
- 인접한 우편번호 찾기
- 결국, 순위 붙이기 문제
- 윈도우 함수를 사용한 스캔 횟수 감소
### 반복 횟수가 정해지지 않은 경우