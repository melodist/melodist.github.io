---
layout: post
title: SQL 레벨업 - 10장. 인덱스 사용
tags: [SQL, SqlLvUp, UF]
permalink: /docs/SQL/SqlLvUp_10
date: 2023-12-11 22:48:00
---
# 인덱스 사용
## 인덱스와 B-tree
### 만능형: B-tree
- 데이터를 트리 구조로 저장하는 형태
- 대부분의 데이터베이스에서는 트리의 리프 노드에만 키값을 저장하는 B+tree 사용
- 루트와 리프의 거리를 가능한 일정하게 유지하므로 검색 성능이 안정적
### 기타 인덱스
- 비트맵 인덱스
  - 데이터를 비트 플래그로 변환
  - 카디널리티가 낮은 필드에 유효
  - 갱신할 때 오버헤드가 크므로 BI/DWH 용도로 사용
- 해시 인덱스
  - 키를 해시 분산해서 등가 검색을 고속으로 실행
  - 등가 검색 외에는 효과가 거의 없고 범위 검색을 할 수 없음
  - PostgreSQL, Oracle 등 일부 DB만 지원
## 인덱스를 잘 활용하려면
### 카디널리티와 선택률
- 카디널리티: 값의 균형을 나타냄
  - 카디널리티가 높은 필드는 모든 레코드에 다른 값이 들어가 있는 유일 키 필드
  - 카디널리티가 낮은 필드는 모든 레코드에 같은 값이 들어가 있는 필드
- 선택률: 특정 필드 값을 지정했을 때 테이블 전체에서 몇 개의 레코드가 선택되는지를 나타냄
### 인덱스를 사용하는 것이 좋은지 판단하려면
- 인덱스를 작성하는 필드 집합의 조건
  - 카디널리티가 높음: 값이 평균치에서 많이 흩어져있음
  - 선택률이 낮음: 한 번의 선택으로 적은 갯수의 레코드가 선택됨, 대략 5~10% 이하가 기준
## 인덱스로 성능 향상이 어려운 경우
### 압축 조건이 존재하지 않음
```sql
SELECT order_id, receive_date
  FROM Orders
```

- 레코드를 압축하는 `WHERE` 구가 없으므로 인덱스로 작성할 필드도 존재하지 않음
### 레코드를 제대로 압축하지 못하는 경우
```sql
SELECT order_id, receive_date
  FROM Orders
 WHERE process_flg = '5'
```

- `process_flg = 5`인 레코드의 선택률이 높을 경우 레코드 갯수가 거의 줄어들지 않으므로 테이블 풀 스캔보다 더 느려질 수도 있음
- 인덱스가 제대로 작동하려면 레코드를 크게 압축할 수 있어야 함

- 입력 매개변수에 따라 선택률이 변동하는 경우 - 1
  ```sql
  SELECT order_id
    FROM orders
   WHERE receive_date BETWEEN :start_date AND :end_date
  ```
  - 조건이 매개변수화 되어 있을 경우 입력에 따라 선택률이 높아지거나 낮아짐
- 입력 매개변수에 따라 선택률이 변동하는 경우 - 2
  ```sql
  SELECT COUNT(*)
    FROM orders
   WHERE shop_id = :sid
  ```
  - 선택률이 높을 경우 인덱스 스캔보다 테이블 풀 스캔이 나음
  - `shop_id` 필드에 인덱스가 존재할 경우 선택률이 높은 경우 오히려 성능이 악화됨
### 인덱스를 사용하지 않는 검색 조건
- 중간 일치, 후방 일치의  LIKE 연산자
```sql
SELECT order_id
  FROM Orders
 WHERE shop_name LIKE '%대공원%'
```
  - `LIKE` 연산자를 사용하는 경우 인덱스는 전방 일치(`대공원%`)에만 적용 가능
- 색인 필드로 연산하는 경우
```sql
SELECT *
  FROM SomeTable
 WHERE col_1 * 1.1 > 100
```
  - 색인 필드로 연산하는 경우에는 인덱스를 사용할 수 없음
  - 검색 조건의 우변에 식을 사용하도록 수정하면 인덱스를 사용할 수 있음 (`WHERE col_1 > 100 / 1.1`)
  - 마찬가지로, 색인 필드에 함수를 사용하는 경우에도 인덱스를 사용할 수 없음
- IS NULL을 사용하는 경우
  - 일반적으로 색인 필드의 데이터에 `NULL`이 존재하지 않기 때문에 인덱스를 사용할 수 없음
- 부정형을 사용하는 경우
  - `<>`, `!=`, `NOT IN`은 인덱스를 사용할 수 없음
## 인덱스를 사용할 수 없는 경우 대처법
### 외부 설정으로 처리 - 깊고 어두운 강 건너기
### 외부 설정을 사용한 대처 방법의 주의점
### 데이터 마트로 대처
### 데이터 마트를 채택할 시 주의점
### 인덱스 온리 스캔으로 대처
### 인덱스 온리 스캔의 주의점