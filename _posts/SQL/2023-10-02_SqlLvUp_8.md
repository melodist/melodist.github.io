---
layout: post
title: SQL 레벨업 - 8장. SQL의 순서
tags: [SQL, SqlLvUp, UF]
permalink: /docs/SQL/SqlLvUp_8
date: 2023-10-02 23:34:00
---
# SQL의 순서
## 레코드에 순번 붙이기
### 기본 키가 한 개의 필드일 경우
- 윈도우 함수를 사용
```sql
SELECT student_id,
			 ROW_NUMBER() OVER (ORDER BY student_id) AS seq
  FROM Weights
```

- 상관 서브쿼리를 사용
```sql
SELECT student_id,
			 (SELECT COUNT(*)
    			FROM Weights W2
     		 WHERE W2.student_id <= W1.student_id) AS seq
  FROM Weights W1
```
  - 윈도우 함수는 인덱스 스캔 1회, 상관 서브쿼리는 테이블 풀 스캔 2회
  - 윈도우 함수를 사용하는 것이 성능 측면에서 좋음
### 기본 키가 여러 개의 필드로 구성되는 경우
- 윈도우 함수를 사용
```sql
SELECT student_id,
			 ROW_NUMBER() OVER (ORDER BY class, student_id) AS seq
  FROM Weights2
```

- 상관 서브쿼리를 사용
```sql
SELECT class, student_id,
			 (SELECT COUNT(*)
    			FROM Weights2 W2
     		 WHERE (W2.class, W2.student_id)
        					<= (W1.class, W1.student_id) ) AS seq
  FROM Weights2 W1
```
  - 다중 필드 비교 사용
  - 암묵적인 자료형 변환이 발생하지 않으므로 기본 키 인덱스도 사용 가능
  - 필드가 3개 이상일 때도 간단하게 확장 가능
### 그룹마다 순번을 붙이는 경우
- 윈도우 함수를 사용
```sql
SELECT class, student_id,
			 ROW_NUMBER() OVER (PARTITION BY class ORDER BY student_id) AS seq
  FROM Weights2
```

- 상관 서브쿼리를 사용
```sql
SELECT class, student_id,
			 (SELECT COUNT(*)
    			FROM Weights2 W2
     		 WHERE W2.class = W1.class
        	 AND W2.student_id = W1.student_id) AS seq
  FROM Weights2 W1
```
  ### 순번과 갱신
  - 테이블에 순번 필드(seq)를 생성
  - 윈도우 함수를 사용
```sql
UPDATE Weights3
   SET seq = (SELECT seq
   							FROM (SELECT class, student_id,
          										ROW_NUMBER() 
                    						OVER (PARTITION BY class
                          								ORDER BY student_id) AS seq)
                        FROM Weights3) SeqTbl			 
  						 WHERE Weights3.class = SeqTbl.class
         				 AND Weights3.student_id = SeqTbl.student_id)
```

- 상관 서브쿼리를 사용
```sql
UPDATE Weights3
	 SET seq = (SELECT COUNT(*)
  							FROM Weights3 W2
         			 WHERE W2.class = Weights3.class
             		 AND W2.student_id <= Weights3.student_id)
```
## 레코드에 순번 붙이기 응용
### 중앙값 구하기
- 집합 지향적 방법
```sql
SELECT AVG(weight)
	FROM (SELECT W1.weight
 					FROM Weights W1, Weights W2
      	 GROUP BY W1.weight
        HAVING SUM(CASE WHEN W2.weight >= W1.weight THEN 1 ELSE 0 END) >= COOUNT(*) /2
        	 AND SUM(CASE WHEN W2.weight <= W1.weight THEN 1 ELSE 0 END) >= COOUNT(*) /2) TMP
```
  -  `CASE`식에 표현한 두 개의 특성 함수로 모집합 `Weights`를 상위 집합과 하위 집합으로 분할
  -  코드가 복잡해서 무엇을 하고 있는지 한 번에 이해하기 어려움
  -  자기 결합을 수행하므로 성능이 나쁨
-  절차 지향적 방법 1 - 세계의 중심을 향해
```sql
SELECT AVG(weight)
	FROM (SELECT W1.weight
 							 ROW_NUMBER() OVER (ORDER BY weight ASC, student_id ASC) hi,
         			 ROW_NUMBER() OVER (ORDER BY weight DESC, student_id DESC) lo,
          FROM Weights) TMP
 WHERE hi IN (lo, lo+1, lo-1)
```
  - `IN` 구문으로 홀수인 경우, 짝수인 경우를 한꺼번에 처리
  - 비슷한 기능의 `RANK` 또는 `DENSE_RANK`는 중복이 발생할 수 있으므로 연속성과 유일성을 갖게 만들 수 없음
  - Weights 테이블에 대한 접근이 1회로 감소, 정렬 2회
  - `ORDER BY`의 정렬키에 기본 키인 student_id를 포함해야 함
    - 포함하지 않을 경우 체중이 같은 학생이 여러 명 있을 때 `NULL`이 발생할 가능성이 있음
- 절차 지향적 방법 2 - 2 빼기 1은 1
```sql
SELECT AVG(weight) AS median
	FROM (SELECT weight,
 							 2 * ROW_NUMBER() OVER (ORDER BY weight)
         			 		 - COUNT(*) OVER() AS diff
          FROM Weights) TMP
 WHERE diff BETWEEN 0 AND 2
```
  - `ROW_NUMBER` 함수로 구한 순번을 2배하고 거기서 `COUNT(*)`를 빼서 `diff`를 구함
  - 중간값에 해당하는 `diff`는 0부터 2 사이의 값을 가짐
  - 이전 방법에 비해 정렬이 1회 감소하므로 성능 향상
### 순번을 사용한 테이블 분할
- 문제. 단절 구간 찾기
  - 집합 지향적 방법 - 집합의 경계선
```sql
SELECT (N1.num + 1) AS gap_start,
			 '~',
    	 (MIN(N2.num) - 1) AS gap_end
	FROM Numbers N1 INNER JOIN Numbers N2
 		ON N2.num > N1.num
 GROUP BY N1.num
HAVING (N1.num + 1) < MIN(N2.num)
```
    - 간단하지만 자기 결합을 사용하여 비용이 높고 실행 계획이 불안정함
  - 절차 지향적 방법 - '다음 레코드'와 비교
  ```sql
SELECT num + 1 AS gap_start,
			 '~',
    	 (num + diff - 1) AS gap_end
	FROM (SELECT num,
 							 MAX(num)
         				OVER(ORDER BY num
             					ROWS BETWEEN 1 FOLLOWING
                  						 AND 1 FOLLWING) - num)
         FROM numbers) TMP(num, diff)
 WHERE diff <> 1
```
    - 윈도우 함수로 '현재 레코드의 다음 레코드'를 구하고 두 레코드의 숫자 차이를 `diff` 필드에 저장
    - 결합을 사용하지 않으므로 성능이 안정적

### 테이블에 존재하는 시퀀스 구하기
- 집합 지향적 방법 - 다시, 집합의 경계선
```sql
SELECT MIN(num) AS low,
			 '~',
    	 MAX(num) AS high
	FROM (SELECT N1.num,
 							 COUNT(N2.num) - N1.num
          FROM Numbers N1 INNER JOIN Numbers N2
 						ON N2.num <= N1.num
      	 GROUP BY N1.num) N(num, gp)
 GROUP BY gp
```
## 시퀀스 객체, IDENTITY 필드, 채번 테이블