---
layout: post
title: SQL 레벨업 - 8장. SQL의 순서
tags: [SQL, SqlLvUp, UF]
permalink: /docs/SQL/SqlLvUp_8
date: 2023-10-02 23:34:00
---
# SQL의 순서
## 레코드에 순번 붙이기
### 기본 키가 한 개의 필드일 경우
- 윈도우 함수를 사용
```sql
SELECT student_id,
			 ROW_NUMBER() OVER (ORDER BY student_id) AS seq
  FROM Weights
```

- 상관 서브쿼리를 사용
```sql
SELECT student_id,
			 (SELECT COUNT(*)
    			FROM Weights W2
     		 WHERE W2.student_id <= W1.student_id) AS seq
  FROM Weights W1
```
  - 윈도우 함수는 인덱스 스캔 1회, 상관 서브쿼리는 테이블 풀 스캔 2회
  - 윈도우 함수를 사용하는 것이 성능 측면에서 좋음
### 기본 키가 여러 개의 필드로 구성되는 경우
- 윈도우 함수를 사용
```sql
SELECT student_id,
			 ROW_NUMBER() OVER (ORDER BY class, student_id) AS seq
  FROM Weights2
```

- 상관 서브쿼리를 사용
```sql
SELECT class, student_id,
			 (SELECT COUNT(*)
    			FROM Weights2 W2
     		 WHERE (W2.class, W2.student_id)
        					<= (W1.class, W1.student_id) ) AS seq
  FROM Weights2 W1
```
  - 다중 필드 비교 사용
  - 암묵적인 자료형 변환이 발생하지 않으므로 기본 키 인덱스도 사용 가능
  - 필드가 3개 이상일 때도 간단하게 확장 가능
### 그룹마다 순번을 붙이는 경우
- 윈도우 함수를 사용
```sql
SELECT class, student_id,
			 ROW_NUMBER() OVER (PARTITION BY class ORDER BY student_id) AS seq
  FROM Weights2
```

- 상관 서브쿼리를 사용
```sql
SELECT class, student_id,
			 (SELECT COUNT(*)
    			FROM Weights2 W2
     		 WHERE W2.class = W1.class
        	 AND W2.student_id = W1.student_id) AS seq
  FROM Weights2 W1
```
  ### 순번과 갱신
  - 테이블에 순번 필드(seq)를 생성
  - 윈도우 함수를 사용
```sql
UPDATE Weights3
   SET seq = (SELECT seq
   							FROM (SELECT class, student_id,
          										ROW_NUMBER() 
                    						OVER (PARTITION BY class
                          								ORDER BY student_id) AS seq)
                        FROM Weights3) SeqTbl			 
  						 WHERE Weights3.class = SeqTbl.class
         				 AND Weights3.student_id = SeqTbl.student_id)
```

- 상관 서브쿼리를 사용
```sql
UPDATE Weights3
	 SET seq = (SELECT COUNT(*)
  							FROM Weights3 W2
         			 WHERE W2.class = Weights3.class
             		 AND W2.student_id <= Weights3.student_id)
```
## 레코드에 순번 붙이기 응용
### 중앙값 구하기
- 집합 지향적 방법

```sql
SELECT AVG(weight)
	FROM (SELECT W1.weight
 					FROM Weights W1, Weights W2
      	 GROUP BY W1.weight
        HAVING SUM(CASE WHEN W2.weight >= W1.weight THEN 1 ELSE 0 END) >= COOUNT(*) /2
        	 AND SUM(CASE WHEN W2.weight <= W1.weight THEN 1 ELSE 0 END) >= COOUNT(*) /2) TMP
```
  -  `CASE`식에 표현한 두 개의 특성 함수로 모집합 `Weights`를 상위 집합과 하위 집합으로 분할
  -  코드가 복잡해서 무엇을 하고 있는지 한 번에 이해하기 어려움
  -  자기 결합을 수행하므로 성능이 나쁨
### 순번을 사용한 테이블 분할
### 테이블에 존재하는 시퀀스 구하기
## 시퀀스 객체, IDENTITY 필드, 채번 테이블