---
layout: post
title: SQL 레벨업 - 9장. 갱신과 데이터 모델
tags: [SQL, SqlLvUp, UF]
permalink: /docs/SQL/SqlLvUp_9
date: 2023-11-01 23:39:00
---
# 갱신과 데이터 모델
## 갱신은 효율적으로
### NULL 채우기
- 문제. NULL인 값을 이전 레코드의 값으로 채우기
```sql
UPDATE OmitTbl
	 SET val = (SELECT val
  							FROM OmitTbl OT1
       				 WHERE OT1.keycol = OmitTbl.keycol
            		 AND OT1.seq = (SELECT MAX(seq)
               										FROM OmitTbl OT2
                         				 WHERE OT2.keycol = OmitTbl.keycol
                              		 AND OT2.seq < OmitTbl.seq
                                 	 AND OT2.val IS NOT NULL))
 WHERE val IS NULL
```
	- 다음과 같은 조건을 갖는 레코드 집합을 구하고, 그 중 가장 큰 seq 필드를 가진 레코드를 찾음
    1. 같은 keycol 필드를 가짐
    2. 현재 레코드보다 작은 seq 필드를 가짐
    3. val 필드가 NULL이 아님
### 반대로 NULL을 작성
- 문제. 위에서 채워진 값을 반대로 NULL로 바꾸기
```sql
UPDATE OmitTbl
	 SET val = CASE WHEN val
  				 = (SELECT val
  							FROM OmitTbl O1
       				 WHERE O1.keycol = OmitTbl.keycol
            		 AND O1.seq = (SELECT MAX(seq)
               										FROM OmitTbl O2
                         				 WHERE O2.keycol = OmitTbl.keycol
                              		 AND O2.seq < OmitTbl.seq
                                 	 AND O2.val IS NOT NULL))
             THEN NULL
             ELSE val END
```
## 레코드에서 필드로의 갱신
- 문제. 레코드 기반 테이블에서 필드 기반 테이블로 데이터 이동
### 필드를 하나씩 갱신
### 다중 필드 할당
### NOT NULL 제약이 걸려있는 경우
## 필드에서 레코드로 변경
## 같은 테이블의 다른 레코드로 갱신
## 갱신이 초래하는 트레이드오프
## 모델 갱신의 주의점
## 시야 협착 : 관련 문제
## 데이터 모델을 지배하는 자가 시스템을 지배한다