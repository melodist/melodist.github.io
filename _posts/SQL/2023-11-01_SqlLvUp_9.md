---
layout: post
title: SQL 레벨업 - 9장. 갱신과 데이터 모델
tags: [SQL, SqlLvUp, UF]
permalink: /docs/SQL/SqlLvUp_9
date: 2023-11-01 23:39:00
---
# 갱신과 데이터 모델
## 갱신은 효율적으로
### NULL 채우기
- 문제. NULL인 값을 이전 레코드의 값으로 채우기
```sql
UPDATE OmitTbl
	 SET val = (SELECT val
  							FROM OmitTbl OT1
       				 WHERE OT1.keycol = OmitTbl.keycol
            		 AND OT1.seq = (SELECT MAX(seq)
               										FROM OmitTbl OT2
                         				 WHERE OT2.keycol = OmitTbl.keycol
                              		 AND OT2.seq < OmitTbl.seq
                                 	 AND OT2.val IS NOT NULL))
 WHERE val IS NULL
```
	- 다음과 같은 조건을 갖는 레코드 집합을 구하고, 그 중 가장 큰 seq 필드를 가진 레코드를 찾음
    1. 같은 keycol 필드를 가짐
    2. 현재 레코드보다 작은 seq 필드를 가짐
    3. val 필드가 NULL이 아님
### 반대로 NULL을 작성
- 문제. 위에서 채워진 값을 반대로 NULL로 바꾸기
```sql
UPDATE OmitTbl
	 SET val = CASE WHEN val
  				 = (SELECT val
  							FROM OmitTbl O1
       				 WHERE O1.keycol = OmitTbl.keycol
            		 AND O1.seq = (SELECT MAX(seq)
               										FROM OmitTbl O2
                         				 WHERE O2.keycol = OmitTbl.keycol
                              		 AND O2.seq < OmitTbl.seq
                                 	 AND O2.val IS NOT NULL))
             THEN NULL
             ELSE val END
```
## 레코드에서 필드로의 갱신
- 문제. 레코드 기반 테이블에서 필드 기반 테이블로 데이터 이동
### 필드를 하나씩 갱신
```sql
UPDATE ScoreCols
	 SET score_en = (SELECT score
  									 FROM ScoreRows SR
            				WHERE SR.student_id = ScoreCols.student_id
                			AND subject = '영어'),
       score_nl = (SELECT score
  									 FROM ScoreRows SR
            				WHERE SR.student_id = ScoreCols.student_id
                			AND subject = '국어'),
       score_mt = (SELECT score
  									 FROM ScoreRows SR
            				WHERE SR.student_id = ScoreCols.student_id
                			AND subject = '수학'),
```
- 3개의 상관 서브쿼리를 실행하므로 성능적으로 좋지 않음
- 과목 수가 늘어날 수록 성능 악화
### 다중 필드 할당
```sql
UPDATE ScoreCols
	 SET (score_en, score_nl, score_mt)
  				= (SELECT MAX(CASE WHEN subject = '영어'
      											 THEN score
                  					 ELSE NULL END) AS score_en,
										MAX(CASE WHEN subject = '국어'
      											 THEN score
                  					 ELSE NULL END) AS score_nl,
										MAX(CASE WHEN subject = '수학'
      											 THEN score
                  					 ELSE NULL END) AS score_mt,
               FROM ScoreRows SR
              WHERE SR.student_id = ScoreCols.student_id)
```
- 테이블 접근은 1회로 감소, `INDEX UNIQUE SCAN`이 `INDEX RANGE SCAN`으로 변함,  `MAX` 함수 정렬 추가
- 다중 필드 할당을 모든 SQL에서 지원하지는 않지만 표준 SQL 기능이므로 지원 가능성 높음
- `MAX` 함수를 이용하여 서브쿼리로 단일한 값을 리턴
### NOT NULL 제약이 걸려있는 경우
## 필드에서 레코드로 변경
## 같은 테이블의 다른 레코드로 갱신
## 갱신이 초래하는 트레이드오프
## 모델 갱신의 주의점
## 시야 협착 : 관련 문제
## 데이터 모델을 지배하는 자가 시스템을 지배한다