---
layout: post
title: SQL 레벨업 - 7장. 서브쿼리
tags: [SQL, SqlLvUp, UF]
permalink: /docs/SQL/SqlLvUp_7
date: 2023-09-14 23:23:00
---
# 서브쿼리
## 서브쿼리가 일으키는 폐해
### 서브쿼리의 문제점
- 서브쿼리의 성능적 문제는 결과적으로 서브쿼리가 실제 데이터를 저장하지 않는다는 점이 원인
1. 연산 비용 추가
  -  서브쿼리에 접근할 때마다 SELECT 구문을 실행하여 데이터를 생성
  -  서브쿼리가 복잡할수록 이러한 실행 비용은 더 높아짐
2. 데이터 I/O 비용 발생
  - 서브쿼리의 데이터 양이 클 경우 TEMP 탈락 현상이 발생할 수 있음
3. 최적화 불가
  - 명시적인 제약 또는 인덱스가 작성되어 있는 테이블과 달리, 서브쿼리에는 메타 정보가 하나도 존재하지 않음
  - 따라서, 옵티마이저가 쿼리를 해석하기 위한 정보를 얻을 수 없음
### 서브쿼리 의존증
- 문제. 고객별 최소 순번 레코드 구하기
  - 서브쿼리를 사용한 방법
 ```sql
  SELECT R1.cust_id, R1.seq, R1.price
  FROM Receipts R1
        INNER JOIN
          (SELECT cust_id, MIN(seq) AS min_seq
            FROM Receipts
            GROUP BY cust_id) R2
    ON R1.cust_id = R2.cust_id
   AND R1.seq = R2.min_seq
```
    - 코드가 복잡해서 읽기 어려움
    - 성능이 좋지 않음
      - 서브쿼리는 대부분 일시적인 영역 (메모리 또는 디스크)에 확보되므로 오버헤드 발생
      - 서브쿼리는 인덱스 또는 제약 정보를 가지지 않기 때문에 최적화 불가능
      - 위의 쿼리는 결합을 필요로 하기 때문에 비용이 높고 실행 계획 변동 리스크 발생
      - Receipts 테이블에 스캔이 두 번 필요

  - 상관 서브쿼리를 사용한 방법
```sql
SELECT cust_id, seq, price
  FROM Receipts R1
 WHERE seq = (SELECT MIN(seq)
 								FROM Receipts R2
         			 WHERE R1.cust_id = R2.cust_id);
```
	- 서브쿼리를 사용할 때와 마찬가지로 테이블 스캔 2번 필요, 성능적인 장점이 없음

  - 윈도우 함수로 결합을 제거
  ```sql
SELECT cust_id, seq, price
  FROM (SELECT cust_id, seq, price,
  							ROW_NUMBER()
         					OVER (PARTITION BY cust_id
                            ORDER BY seq) AS row_seq
          FROM Reciepts) WORK
  WHERE WORK.row_seq = 1;
```
		- 윈도우 함수 ROW_NUMBER를 사용하여 각 사용자의 구매 이력에 번호 부여
### 장기적 관점에서의 리스크 관리
### 서브쿼리 의존증 - 응용편
### 서브쿼리는 정말 나쁠까?
## 서브쿼리 사용이 더 나은 경우