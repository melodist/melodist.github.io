---
layout: post
title: 운영체제 - Thread
tags: [OS, UF]
permalink: /docs/OS/Thread
date: 2021-03-11 09:04:00
---

# Thread

## Thread (스레드)

- Light Weight Process라고도 함
- 하나의 프로세스에 여러 개의 스레드를 생성하고 동시에 실행할 수 있으며 프로세스 간에 데이터 접근이 불가능하여 IPC를 이용해야 하는 반면, 각각의 스레드는 프로세스의 모든 데이터에 접근할 수 있다.
- Thread는 각자 실행이 가능한 stack을 가진다.

### 멀티 프로세싱과 Thread

Multi tasking : 1CPU에 여러 프로세스

Multi Processing: 여러 CPU에 하나의 프로세스. 각 CPU에서 여러 개의 thread를 실행하여 프로세스의 실행 속도를 높인다.

### Thread의 장점

1. 사용자에 대한 응답성 향상
   - ex. 스레드 A: 1부터 100만까지 더함 / 스레드 B: 스레드 A에서 현재까지 더해진 값을 확인

2. 자원 공유 효율
   - IPC 기법과 같은 자원 공유를 위한 번거로운 작업이 불필요함
   - 프로세스 안에 있으므로 프로세스의 모든 데이터에 접근 가능
3. 작업이 분리되어 코드가 간결해짐

### Thread의 단점

1. 프로세스 내 하나의 thread에만 문제가 있어도 프로세스 전체의 thread가 영향을 받는다
2. Thread가 지나치게 많으면 context switching이 많이 일어나 성능이 저하된다.
   Linux에서는 thread를 process처럼 취급하므로 thread를 많이 생성하면 그만큼 스케쥴링해야 하는 thread 수가 늘어나고 context switching이 많이 일어난다.

### Thread vs. Process

- 프로세스는 독립적, 스레드는 프로세스의 서브셋
- 프로세스는 각각 독립적인 자원을 가짐, 스레드는 프로세스 자원 공유
- 프로세스는 자신만의 주소영역을 가짐, 스레드는 주소영역 공유
- 프로세스간에는 IPC 기법으로 통신해야 함, 스레드는 필요 없음

## Synchronization (동기화)

작업들 사이에 실행 시기를 맞추는 것으로 여러 thread가 동일한 자원에 접근할 시 동기화 이슈가 발생한다.

### Mutual Exclusion (상호 배제)

Thread가 프로세스의 모든 데이터에 접근할 수 있으므로 여러 thread가 변경하는 공유 변수에 대해서는 Exclusive Access가 필요하다. 한 thread가 공유 변수를 갱신하는 동안에는 다른 thread가 동시 접근하지 못하도록 막아야 한다.

```python
import threading

g_count = 0

def thread_main():
    global g_count
    for i in range(10000):
    # for i in range(100000):
        g_count = g_gount + 1
        
threads = []

for i in range(50):
    th = threading.Thread(target = thread_main) # Thread 객체를 생성
    threads.append(th)
    
for th in threads:
    th.start() # Thread 객체 시작
    
for th in threads:
    th.join() # 다른 thread가 끝날 때까지 기다림 -> thread 동기화
    
print('g_count = ', g_count) # g_count = 500000 / g_count = 3686352
```

Context Switching 과정에서 g_count 값이 무작위로 변경되면서 제대로 된 값이 출력되지 않았다.

```python
import threading

g_count = 0

def thread_main():
    global g_count
    lock.acquire()
    for i in range(100000):
        g_count = g_gount + 1
    lock.release()
        
lock = threading.lock() # Mutual Exclusion
threads = []

for i in range(50):
    th = threading.Thread(target = thread_main) # Thread 객체를 생성
    threads.append(th)
    
for th in threads:
    th.start() # Thread 객체 시작
    
for th in threads:
    th.join() # 다른 thread가 끝날 때까지 기다림 -> thread 동기화
    
print('g_count = ', g_count) # g_count = 5000000
```

lock을 생성하여 lock을 가진 thread만 g_count의 값을 변경할 수 있도록 하고 동기화 이슈를 해결하였다.

## Mutex와 Semaphore

Critical Section (임계 구역)에 대한 접근을 막기 위한 LOCKING 메커니즘

- Mutex (binary semaphore): 임계 구역에 하나의 스레드만 들어갈 수 있음

- Semaphore: 임계 구역에 counter만큼의 스레드가 들어갈 수 있음

## References

[컴퓨터 공학 전공 필수 올인원 패키지 Online](https://www.fastcampus.co.kr/dev_online_cs)