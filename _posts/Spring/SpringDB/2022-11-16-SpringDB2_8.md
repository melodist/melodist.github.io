---
layout: post
title: 스프링 DB 2편 - 데이터 접근 기술 - 8. 활용 방안
tags: [Spring, SpringDB2, UF]
permalink:  docs Spring SpringDB2_8
date: 2022-11-16 21:33:00
---
# 데이터 접근 기술 - 활용 방안
## 스프링 데이터 JPA 예제와 트레이드 오프

**클래스 의존 관계**
![데이터 접근 기술 - 활용 방안 - 01  클래스 의존 관계](https://user-images.githubusercontent.com/52024566/202184749-f747f1d7-d5d9-48d7-b7e9-860fa39ea10e.png)

**런타임 객체 의존 관계**
![데이터 접근 기술 - 활용 방안 - 02  런타임 의존 관계](https://user-images.githubusercontent.com/52024566/202184757-5136f387-f16f-41b0-91c6-e401394df959.png)

- 중간에서 `JpaItemRepositoryV2`가 어댑터 역할을 해준 덕분에 `MemberService`가 사용하는 `MemberRepository` 인터페이스를 그대로 유지할 수 있고 클라이언트인 `MemberService` 의 코드를 변경하지 않아도 되는 장점이 있음

**고민**
- 구조를 맞추기 위해서, 중간에 어댑터가 들어가면서 전체 구조가 너무 복잡해지고 사용하는 클래스도 많아지는 단점이 생김
- 실제 이 코드를 구현해야하는 개발자 입장에서 보면 중간에 어댑터도 만들고, 실제 코드까지 만들어야 하는 불편함이 발생
- 유지보수 관점에서 `ItemService`를 변경하지 않고 `ItemRepository`의 구현체를 변경할 수 있는 장점이 있음. 즉, DI, OCP 원칙을 지킬 수 있다는 좋은 점이 분명히 있지만 반대로 구조가 복잡해지면서 어댑터 코드와 실제 코드까지 함께 유지보수 해야 하는 어려움도 발생

**다른 선택**
여기서 완전히 다른 선택을 할 수도 있음
`ItemService` 코드를 일부 고쳐서 직접 스프링 데이터 JPA를 사용하는 방법
DI, OCP 원칙을 포기하는 대신에, 복잡한 어댑터를 제거하고, 구조를 단순하게 가져갈 수 있는 장점이 있음

**클래스 의존 관계**
![데이터 접근 기술 - 활용 방안 - 03  클래스 의존 관계](https://user-images.githubusercontent.com/52024566/202184759-1c0c9002-a793-4cc5-8835-0d67d62affc6.png)

**런타임 의존 관계**
![데이터 접근 기술 - 활용 방안 - 04  런타임 의존 관계](https://user-images.githubusercontent.com/52024566/202184763-1a3d6dc9-0cd0-4099-bfa8-95d00c1368d9.png)

- `ItemService`에서 스프링 데이터 JPA로 만든 리포지토리를 직접 참조. 이 경우 `ItemService` 코드를 변경해야 함

![데이터 접근 기술 - 활용 방안 - 05  복잡한 쿼리 분리](https://user-images.githubusercontent.com/52024566/202184765-5e2b8ab2-f82b-4cbe-a8b0-947ecd9602c0.png)

**트레이드 오프**
- DI, OCP를 지키기 위해 어댑터를 도입하고, 더 많은 코드를 유지
- 어댑터를 제거하고 구조를 단순하게 가져가지만 DI, OCP를 포기하고, `ItemService` 코드를 직접 변경

결국 여기서 발생하는 트레이드 오프는 구조의 안정성 vs 단순한 구조와 개발의 편리성 사이의 선택. 이 둘 중에 하나의 정답만 있는 것은 아님. 어떤 상황에서는 구조의 안정성이 매우 중요하고, 어떤 상황에서는 단순한 것이 더 나은 선택일 수 있음

개발을 할 때는 항상 자원이 무한한 것이 아님. 그리고 어설픈 추상화는 오히려 독이 되는 경우도 많음. 무엇보다 추상화도 비용이 듦. 인터페이스도 비용이 든다. 여기서 말하는 비용은 유지보수 관점에서의 비용을 의미. 이 추상화 비용을 넘어설 만큼 효과가 있을 때 추상화를 도입하는 것이 실용적이

이런 선택에서 하나의 정답이 있는 것은 아니지만, 프로젝트의 현재 상황에 맞는 더 적절한 선택지가 있음. 그리고 현재 상황에 맞는 선택을 하는 개발자가 좋은 개발자임

## 실용적인 구조

**복잡한 쿼리 분리**
![데이터 접근 기술 - 활용 방안 - 05  복잡한 쿼리 분리](https://user-images.githubusercontent.com/52024566/202730259-2a567e82-0b02-4827-a368-4b6e21aed491.png)

- `ItemRepositoryV2`는 스프링 데이터 JPA의 기능을 제공하는 리포지토리
- `ItemQueryRepositoryV2`는 Querydsl을 사용해서 복잡한 쿼리 기능을 제공하는 리포지토리

이렇게 둘을 분리하면 기본 CRUD와 단순 조회는 스프링 데이터 JPA가 담당하고, 복잡한 조회 쿼리는 Querydsl이 담당
물론 `ItemService`는 기존 `ItemRepository`를 사용할 수 없기 때문에 코드를 변경해야 함

**ItemRepositoryV2**
```java
import hello.itemservice.domain.Item;
import org.springframework.data.jpa.repository.JpaRepository;

public interface ItemRepositoryV2 extends JpaRepository<Item, Long> {
}
```

- `ItemRepositoryV2`는 `JpaRepository`를 인터페이스 상속 받아서 스프링 데이터 JPA의 기능을 제공하는 리포지토리가 됨
- 기본 CRUD는 이 기능을 사용
- 여기에 추가로 단순한 조회 쿼리들을 추가

**ItemQueryRepositoryV2**
```java
import com.querydsl.core.types.dsl.BooleanExpression;
import com.querydsl.jpa.impl.JPAQueryFactory;
import hello.itemservice.domain.Item;
import hello.itemservice.repository.ItemSearchCond;
import org.springframework.stereotype.Repository;
import org.springframework.util.StringUtils;

import javax.persistence.EntityManager;
import java.util.List;

import static hello.itemservice.domain.QItem.item;

@Repository
public class ItemQueryRepositoryV2 {
  
    private final JPAQueryFactory query;
  
    public ItemQueryRepositoryV2(EntityManager em) {
        this.query = new JPAQueryFactory(em);
    }
  
    public List<Item> findAll(ItemSearchCond cond) {
        return query.select(item)
          .from(item)
          .where(
              maxPrice(cond.getMaxPrice()),
              likeItemName(cond.getItemName()))
          .fetch();
    }
  
    private BooleanExpression likeItemName(String itemName) {
        if (StringUtils.hasText(itemName)) {
            return item.itemName.like("%" + itemName + "%");
        }
        return null;
    }
  
    private BooleanExpression maxPrice(Integer maxPrice) {
        if (maxPrice != null) {
            return item.price.loe(maxPrice);
        }
        return null;
    }
}
```

- `ItemQueryRepositoryV2`는 Querydsl을 사용해서 복잡한 쿼리 문제를 해결
- Querydsl을 사용한 쿼리 문제에 집중되어 있어서, 복잡한 쿼리는 이 부분만 유지보수 하면 되는 장점

**ItemServiceV2**
```java
import hello.itemservice.domain.Item;
import hello.itemservice.repository.ItemSearchCond;
import hello.itemservice.repository.ItemUpdateDto;
import hello.itemservice.repository.v2.ItemRepositoryV2;
import hello.itemservice.repository.v2.ItemQueryRepositoryV2;
import lombok.RequiredArgsConstructor;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.util.List;
import java.util.Optional;

@Service
@RequiredArgsConstructor
@Transactional
public class ItemServiceV2 implements ItemService {
  
    private final ItemRepositoryV2 itemRepositoryV2;
    private final ItemQueryRepositoryV2 itemQueryRepositoryV2;
  
    @Override
    public Item save(Item item) {
        return itemRepositoryV2.save(item);
    }
  
    @Override
    public void update(Long itemId, ItemUpdateDto updateParam) {
        Item findItem = findById(itemId).orElseThrow();
        findItem.setItemName(updateParam.getItemName());
        findItem.setPrice(updateParam.getPrice());
        findItem.setQuantity(updateParam.getQuantity());
    }
  
    @Override
    public Optional<Item> findById(Long id) {
        return itemRepositoryV2.findById(id);
    }
  
    @Override
    public List<Item> findItems(ItemSearchCond cond) {
        return itemQueryRepositoryV2.findAll(cond);
    }
}
```

- 기존 `ItemServiceV1` 코드를 남겨두기 위해서 `ItemServiceV2` 생성
- `ItemServiceV2`는 `ItemRepositoryV2`와 `ItemQueryRepositoryV2`를 의존

**V2Config**
```java
import hello.itemservice.repository.ItemRepository;
import hello.itemservice.repository.jpa.JpaItemRepositoryV3;
import hello.itemservice.repository.v2.ItemQueryRepositoryV2;
import hello.itemservice.repository.v2.ItemRepositoryV2;
import hello.itemservice.service.ItemService;
import hello.itemservice.service.ItemServiceV2;
import lombok.RequiredArgsConstructor;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

import javax.persistence.EntityManager;

@Configuration
@RequiredArgsConstructor
public class V2Config {
  
    private final EntityManager em;
    private final ItemRepositoryV2 itemRepositoryV2; //SpringDataJPA
  
    @Bean
    public ItemService itemService() {
        return new ItemServiceV2(itemRepositoryV2, itemQueryRepository());
    }
  
    @Bean
    public ItemQueryRepositoryV2 itemQueryRepository() {
        return new ItemQueryRepositoryV2(em);
    }
  
    @Bean
    public ItemRepository itemRepository() {
        return new JpaItemRepositoryV3(em);
    }
}
```

- `ItemServiceV2`를 등록한 부분을 주의. `ItemServiceV1`이 아니라 `ItemServiceV2`
- `ItemRepository`는 테스트에서 사용하므로 여전히 필요

**ItemServiceApplication - 변경**
```java
//@Import(QuerydslConfig.class)
@Import(V2Config.class)
@SpringBootApplication(scanBasePackages = "hello.itemservice.web")
public class ItemServiceApplication {}
```
- `V2Config`를 사용하도록 변경

> 참고: 스프링 데이터 JPA가 제공하는 커스텀 리포지토리를 사용해도 비슷하게 문제를 해결할 수는 있다.

## 다양한 데이터 접근 기술 조합
## 정리