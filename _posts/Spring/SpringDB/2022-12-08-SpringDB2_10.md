---
layout: post
title: 스프링 DB 2편 - 10. 스프링 트랜잭션 전파1 - 기본
tags: [Spring, SpringDB2, UF]
permalink:  docs Spring SpringDB2_10
date: 2022-12-08 23:06:00
---
# 스프링 트랜잭션 전파1 - 기본
## 스프링 트랜잭션 전파1 - 커밋, 롤백

**BasicTxTest**
```java
import lombok.extern.slf4j.Slf4j;
import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.boot.test.context.TestConfiguration;
import org.springframework.context.annotation.Bean;
import org.springframework.jdbc.datasource.DataSourceTransactionManager;
import org.springframework.transaction.PlatformTransactionManager;
import org.springframework.transaction.TransactionStatus;
import org.springframework.transaction.interceptor.DefaultTransactionAttribute;

import javax.sql.DataSource;

@Slf4j
@SpringBootTest
public class BasicTxTest {
  
    @Autowired
    PlatformTransactionManager txManager;
  
    @TestConfiguration
    static class Config {
        @Bean
        public PlatformTransactionManager transactionManager(DataSource dataSource) {
            return new DataSourceTransactionManager(dataSource);
        }
    }
  
    @Test
    void commit() {
        log.info("트랜잭션 시작");
        TransactionStatus status = txManager.getTransaction(new DefaultTransactionAttribute());
      
        log.info("트랜잭션 커밋 시작");
        txManager.commit(status);
        log.info("트랜잭션 커밋 완료");
    }
  
    @Test
    void rollback() {
        log.info("트랜잭션 시작");
        TransactionStatus status = txManager.getTransaction(new DefaultTransactionAttribute());
      
        log.info("트랜잭션 롤백 시작");
        txManager.rollback(status);
        log.info("트랜잭션 롤백 완료");
    }
}
```

- `@TestConfiguration`: 해당 테스트에서 필요한 스프링 설정을 추가
- `DataSourceTransactionManager`를 스프링 빈으로 등록. 이후 트랜잭션 매니저인 `PlatformTransactionManager`를 주입 받으면 방금 등록한 `DataSourceTransactionManager`가 주입됨

**실행하기 전에 트랜잭션 관련 로그를 확인할 수 있도록 다음을 추가**
`application.properties` 추가
```properties
logging.level.org.springframework.transaction.interceptor=TRACE
logging.level.org.springframework.jdbc.datasource.DataSourceTransactionManager=DEBUG
#JPA log
logging.level.org.springframework.orm.jpa.JpaTransactionManager=DEBUG
logging.level.org.hibernate.resource.transaction=DEBUG
#JPA SQL
logging.level.org.hibernate.SQL=DEBUG
```

**commit()**
`txManager.getTransaction(new DefaultTransactionAttribute())`
트랜잭션 매니저를 통해 트랜잭션을 시작(획득)

`txManager.commit(status)`
트랜잭션을 커밋

**commit() - 실행 로그**
```
ringtx.propagation.BasicTxTest : 트랜잭션 시작
DataSourceTransactionManager : Creating new transaction with name [null]
DataSourceTransactionManager : Acquired Connection [conn0] for JDBC
transaction
DataSourceTransactionManager : Switching JDBC Connection [conn0] to manual commit
ringtx.propagation.BasicTxTest : 트랜잭션 커밋 시작
DataSourceTransactionManager : Initiating transaction commit
DataSourceTransactionManager : Committing JDBC transaction on Connection [conn0]
DataSourceTransactionManager : Releasing JDBC Connection [conn0] after transaction
ringtx.propagation.BasicTxTest : 트랜잭션 커밋 완료
```

**rollback()**
`txManager.getTransaction(new DefaultTransactionAttribute())`
트랜잭션 매니저를 통해 트랜잭션을 시작(획득)

`txManager.rollback(status)`
트랜잭션을 롤백

**rollback() - 실행 로그**
```
ringtx.propagation.BasicTxTest : 트랜잭션 시작
DataSourceTransactionManager : Creating new transaction with name [null]
DataSourceTransactionManager : Acquired Connection [conn0] for JDBC
transaction
DataSourceTransactionManager : Switching JDBC Connection [conn0] to manual commit
ringtx.propagation.BasicTxTest : 트랜잭션 롤백 시작
DataSourceTransactionManager : Initiating transaction rollback
DataSourceTransactionManager : Rolling back JDBC transaction on Connection [conn0]
DataSourceTransactionManager : Releasing JDBC Connection [conn0] after transaction
ringtx.propagation.BasicTxTest : 트랜잭션 롤백 완료
```

## 스프링 트랜잭션 전파2 - 트랜잭션 두 번 사용

이번에는 트랜잭션이 각각 따로 사용되는 경우를 확인해보자.
이 예제는 트랜잭션1이 완전히 끝나고나서 트랜잭션2를 수행한다.

**double_commit() - BasicTxTest 추가**
```java
@Test
void double_commit() {
    log.info("트랜잭션1 시작");
    TransactionStatus tx1 = txManager.getTransaction(new DefaultTransactionAttribute());
    log.info("트랜잭션1 커밋");
    txManager.commit(tx1);
  
    log.info("트랜잭션2 시작");
    TransactionStatus tx2 = txManager.getTransaction(new DefaultTransactionAttribute());
    log.info("트랜잭션2 커밋");
    txManager.commit(tx2);
}
```

**double_commit() - 실행 로그**
```
트랜잭션1 시작
Creating new transaction with name [null]: PROPAGATION_REQUIRED,ISOLATION_DEFAULT
Acquired Connection [HikariProxyConnection@1064414847 wrapping conn0] for JDBC transaction
Switching JDBC Connection [HikariProxyConnection@1064414847 wrapping conn0] to manual commit
트랜잭션1 커밋
Initiating transaction commit
Committing JDBC transaction on Connection [HikariProxyConnection@1064414847 wrapping conn0]
Releasing JDBC Connection [HikariProxyConnection@1064414847 wrapping conn0] after transaction

트랜잭션2 시작
Creating new transaction with name [null]: PROPAGATION_REQUIRED,ISOLATION_DEFAULT
Acquired Connection [HikariProxyConnection@778350106 wrapping conn0] for JDBC transaction
Switching JDBC Connection [HikariProxyConnection@778350106 wrapping conn0] to manual commit
트랜잭션2 커밋
Initiating transaction commit
Committing JDBC transaction on Connection [HikariProxyConnection@778350106 wrapping conn0]
Releasing JDBC Connection [HikariProxyConnection@778350106 wrapping conn0] after transaction
```

**트랜잭션1**
- `Acquired Connection [HikariProxyConnection@1064414847 wrapping conn0] for JDBC transaction`
  - 트랜잭션1을 시작하고, 커넥션 풀에서 `conn0` 커넥션을 획득
- `Releasing JDBC Connection [HikariProxyConnection@1064414847 wrapping conn0] after transaction`
  - 트랜잭션1을 커밋하고, 커넥션 풀에 `conn0` 커넥션을 반납

**트랜잭션2**
- `Acquired Connection [HikariProxyConnection@ 778350106 wrapping conn0] for JDBC transaction`
  - 트랜잭션2을 시작하고, 커넥션 풀에서 conn0 커넥션을 획득
- `Releasing JDBC Connection [HikariProxyConnection@ 778350106 wrapping conn0] after transaction`
  - 트랜잭션2을 커밋하고, 커넥션 풀에 conn0 커넥션을 반납

**주의!**
로그를 보면 트랜잭션1과 트랜잭션2가 같은 `conn0`커넥션을 사용중. 이것은 중간에 커넥션 풀 때문에 그런 것. 트랜잭션1은 `conn0` 커넥션을 모두 사용하고 커넥션 풀에 반납까지 완료. 이후에 트랜잭션2가 `conn0`를 커넥션 풀에서 획득한 것. 따라서 둘은 완전히 다른 커넥션으로 인지하는 것이 맞음
그렇다면 둘을 구분할 수 있는 다른 방법은?
히카리 커넥션 풀에서 커넥션을 획득하면 실제 커넥션을 그대로 반환하는 것이 아니라 내부 관리를 위해 히카리 프록시 커넥션이라는 객체를 생성해서 반환. 물론 내부에는 실제 커넥션이 포함되어 있음. 이 객체의 주소를 확인하면 커넥션 풀에서 획득한 커넥션을 구분할 수 있음

- 트랜잭션1: `Acquired Connection [HikariProxyConnection@1000000 wrapping conn0]`
- 트랜잭션2: `Acquired Connection [HikariProxyConnection@2000000 wrapping conn0]`

히카리 커넥션풀이 반환해주는 커넥션을 다루는 프록시 객체의 주소가 트랜잭션1은 `HikariProxyConnection@1000000`이고, 트랜잭션2는 `HikariProxyConnection@2000000`으로 서로 다른 것을 확인할 수 있음
결과적으로 `conn0`을 통해 커넥션이 재사용 된 것을 확인할 수 있고,
`HikariProxyConnection@1000000`, `HikariProxyConnection@2000000`을 통해 각각 커넥션 풀에서 커넥션을 조회한 것을 확인할 수 있음

![스프링 트랜잭션 전파1 - 01  트랜잭션 두 번 사용](https://user-images.githubusercontent.com/52024566/207069475-3867f020-359b-4594-95e7-db806fca33e1.png)

![스프링 트랜잭션 전파1 - 02  트랜잭션 두 번 사용](https://user-images.githubusercontent.com/52024566/207069481-aa73f95e-b324-4e05-8c91-c9f12a1a1ed9.png)

- 트랜잭션이 각각 수행되면서 사용되는 DB 커넥션도 각각 다름
- 이 경우 트랜잭션을 각자 관리하기 때문에 전체 트랜잭션을 묶을 수 없음. 예를 들어서 트랜잭션1이 커밋하고, 트랜잭션2가 롤백하는 경우 트랜잭션1에서 저장한 데이터는 커밋되고, 트랜잭션2에서 저장한 데이터는 롤백됨

**double_commit_rollback() - BasicTxTest 추가**
```java
@Test
void double_commit_rollback() {
    log.info("트랜잭션1 시작");
    TransactionStatus tx1 = txManager.getTransaction(new DefaultTransactionAttribute());
    log.info("트랜잭션1 커밋");
    txManager.commit(tx1);
  
    log.info("트랜잭션2 시작");
    TransactionStatus tx2 = txManager.getTransaction(new DefaultTransactionAttribute());
    log.info("트랜잭션2 롤백");
    txManager.rollback(tx2);
}
```

- 예제에서는 트랜잭션1은 커밋하고, 트랜잭션2는 롤백
- 전체 트랜잭션을 묶지 않고 각각 관리했기 때문에, 트랜잭션1에서 저장한 데이터는 커밋되고, 트랜잭션2 에서 저장한 데이터는 롤백

**double_commit_rollback() - 실행 로그**
```
트랜잭션1 시작
Creating new transaction with name [null]: PROPAGATION_REQUIRED,ISOLATION_DEFAULT
Acquired Connection [HikariProxyConnection@1943867171 wrapping conn0] for JDBC transaction
Switching JDBC Connection [HikariProxyConnection@1943867171 wrapping conn0] to manual commit
트랜잭션1 커밋
Initiating transaction commit
Committing JDBC transaction on Connection [HikariProxyConnection@1943867171 wrapping conn0]
Releasing JDBC Connection [HikariProxyConnection@1943867171 wrapping conn0] after transaction

트랜잭션2 시작
Creating new transaction with name [null]: PROPAGATION_REQUIRED,ISOLATION_DEFAULT
Acquired Connection [HikariProxyConnection@239290560 wrapping conn0] for JDBC transaction
Switching JDBC Connection [HikariProxyConnection@239290560 wrapping conn0] to manual commit
트랜잭션2 롤백
Initiating transaction rollback
Rolling back JDBC transaction on Connection [HikariProxyConnection@239290560 wrapping conn0]
Releasing JDBC Connection [HikariProxyConnection@239290560 wrapping conn0] after transaction
```

로그를 보면 트랜잭션1은 커밋되지만, 트랜잭션2는 롤백되는 것을 확인할 수 있음

![스프링 트랜잭션 전파1 - 03  트랜잭션 두 번 사용](https://user-images.githubusercontent.com/52024566/207069484-91a16f81-be99-46a7-9ee6-eb462bcd8328.png)

![스프링 트랜잭션 전파1 - 04  트랜잭션 두 번 사용](https://user-images.githubusercontent.com/52024566/207069487-3a6d9bf8-8f6b-4712-9ef8-82ed8a81391d.png)

## 스프링 트랜잭션 전파3 - 전파 기본
## 스프링 트랜잭션 전파4 - 전파 예제
## 스프링 트랜잭션 전파5 - 외부 롤백
## 스프링 트랜잭션 전파6 - 내부 롤백
## 스프링 트랜잭션 전파7 - REQUIRES_NEW
## 스프링 트랜잭션 전파8 - 다양한 전파 옵션