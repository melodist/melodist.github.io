---
layout: post
title: 스프링 DB 1편 - 데이터 접근 핵심 원리 - 3. 데이터 접근 기술 - 테스트
tags: [Spring, SpringDB1, UF]
permalink: /docs/Spring/SpringDB1_3
date: 2022-08-24 22:32:00
---
# 데이터 접근 기술 - 테스트

## 데이터베이스 연동

데이터 접근 기술을 개발할 때에는 실제 데이터베이스에 접근해서 데이터를 잘 저장하고 조회할 수 있는지 확인하는 것이 필요

테스트를 실행할 때 실제 데이터베이스를 연동해서 진행
앞서 개발한 `ItemRepositoryTest`를 통해서 테스트를 진행

**main - application.properties**
`src/main/resources/application.properties`
```properties
spring.profiles.active=local
spring.datasource.url=jdbc:h2:tcp://localhost/~/test
spring.datasource.username=sa

logging.level.org.springframework.jdbc=debug
```
**test - application.properties**
`src/test/resources/application.properties`
```properties
spring.profiles.active=test
```

테스트 케이스는 `src/test`에 있기 때문에, 실행하면 `src/test`에 있는 `application.properties` 파일이 우선순위를 가지고 실행. 그런데 테스트용 설정에는 `spring.datasource.url` 과 같은 데이터베이스 연결 설정이 없음

테스트 케이스에서도 데이터베이스에 접속할 수 있게 test의 `aplication.properties` 를 다음과 같이 수정

**test - application.properties 수정**
`src/test/resources/application.properties`
```properties
spring.profiles.active=test
spring.datasource.url=jdbc:h2:tcp://localhost/~/test
spring.datasource.username=sa

logging.level.org.springframework.jdbc=debug
```

### 테스트 실행 - 로컬DB

**@SpringBootTest**
```java
@SpringBootTest
class ItemRepositoryTest {}
```

- `ItemRepositoryTest`는 `@SpringBootTest`를 사용. `@SpringBootTest` 는 `@SpringBootApplication`를 찾아서 설정으로 사용

**@SpringBootApplication**
```java
@Slf4j
//@Import(MemoryConfig.class)
//@Import(JdbcTemplateV1Config.class)
//@Import(JdbcTemplateV2Config.class)
@Import(JdbcTemplateV3Config.class)
@SpringBootApplication(scanBasePackages = "hello.itemservice.web")
public class ItemServiceApplication {}
```

- `@SpringBootApplication` 설정이 과거에는 `MemoryConfig.class`를 사용하다가 이제는 `JdbcTemplateV3Config.class`를 사용하도록 변경. 따라서 테스트도 `JdbcTemplate`을 통해 실제 데이터베이스를 호출
- `MemoryItemRepository` → `JdbcTemplateItemRepositoryV3`

**실행 결과**
- `updateitem()`: 성공
- `save()`: 성공
- `findItems()`: 실패

`findItems()`는 다음과 같은 오류를 내면서 실패
```
java.lang.AssertionError:
Expecting actual:
  [Item(id=7, itemName=ItemTest, price=10000, quantity=10),
    Item(id=8, itemName=itemA, price=10000, quantity=10),
    Item(id=9, itemName=itemB, price=20000, quantity=20),
    Item(id=10, itemName=itemA, price=10000, quantity=10),
...
```

`findItems()` 코드를 확인해보면 상품을 3개 저장하고, 조회

**ItemRepositoryTest.findItems()**
```java
@Test
void findItems() {
    //given
    Item item1 = new Item("itemA-1", 10000, 10);
    Item item2 = new Item("itemA-2", 20000, 20);
    Item item3 = new Item("itemB-1", 30000, 30);
  
    itemRepository.save(item1);
    itemRepository.save(item2);
    itemRepository.save(item3);
  
    //여기서 3개 이상이 조회되는 문제가 발생
    test(null, null, item1, item2, item3);
}
```

결과적으로 테스트에서 저정한 3개의 데이터가 조회되어야 하는데, 기대보다 더 많은 데이터가 조회됨

**실패 원인**
1. 테스트를 실행할 때 `TestDataInit`이 실행? 이 문제는 아님. `TestDataInit`은 프로필이 `local`일 때만 동작하는데, 테스트 케이스를 실행할 때는 프로필이 `spring.profiles.active=test`이기 때문에 초기화 데이터가 추가되지 않음
2. 문제는 H2 데이터베이스에 이미 과거에 서버를 실행하면서 저장했던 데이터가 보관되어 있기 때문. 이 데이터가 현재 테스트에 영향을 줌

**H2 데이터베이스 데이터 확인**
- http://localhost:8082
- `SELECT * FROM ITEM`을 실행하면 이미 서버를 실행해서 확인 할 때의 데이터가 저장되어 있는 것을 확인할 수 있음

## 데이터베이스 분리

로컬에서 사용하는 애플리케이션 서버와 테스트에서 같은 데이터베이스를 사용하고 있으니 테스트에서 문제가 발생
이런 문제를 해결하기 위해 테스트를 다른 환경과 철저하게 분리

가장 간단한 방법은 테스트 전용 데이터베이스를 별도로 운영하는 것

- H2 데이터베이스를 용도에 따라 2가지로 구분
  - `jdbc:h2:tcp://localhost/~/test` local에서 접근하는 서버 전용 데이터베이스
  - `jdbc:h2:tcp://localhost/~/testcase` test 케이스에서 사용하는 전용 데이터베이스

### 데이터베이스 파일 생성 방법
- 데이터베이스 서버를 종료하고 다시 실행
- 사용자명은 sa 입력
- JDBC URL에 다음 입력
- `jdbc:h2:~/testcase` (최초 한번)
- `~/testcase.mv.db` 파일 생성 확인
- 이후부터는 `jdbc:h2:tcp://localhost/~/testcase` 접속

### 테이블 생성하기
`testcase` 데이터베이스에도 `item` 테이블을 생성

`sql/schema.sql` 파일 참고
```sql
drop table if exists item CASCADE;
create table item
(
    id bigint generated by default as identity,
    item_name varchar(10),
    price integer,
    quantity integer,
    primary key (id)
);
```

### 접속 정보 변경
`main`에 있는 `application.properties`는 그대로 유지하고, `test`에 있는 `application.properties`만 변경해야 함

**main - application.properties**
`src/main/resources/application.properties`

```properties
spring.profiles.active=local
spring.datasource.url=jdbc:h2:tcp://localhost/~/test
spring.datasource.username=sa
```

**test - application.properties**
`src/test/resources/application.properties`
```properties
spring.profiles.active=test
spring.datasource.url=jdbc:h2:tcp://localhost/~/testcase
spring.datasource.username=sa
```

접속 정보가 `jdbc:h2:tcp://localhost/~/test` → `jdbc:h2:tcp://localhost/~/testcase`로 변경됨

- `findItems()` 테스트만 단독으로 실행
- 처음에는 실행에 성공
- 그런데 같은 `findItems()` 테스트를 다시 실행하면 테스트에 실패

- 테스트를 2번째 실행할 때 실패하는 이유는 `testcase` 데이터베이스에 접속해서 `item` 테이블의 데이터를 확인하면 알 수 있음
- 처음 테스트를 실행할 때 저장한 데이터가 계속 남아있기 때문에 두번째 테스트에 영향
- 이 문제는 `save()` 같은 다른 테스트가 먼저 실행되고 나서 findItems() 를 실행할 때도 발생. 다른 테스트에서 이미 데이터를 추가했기 때문에 테스트 데이터가 오염됨
- 이 문제를 해결하려면 각각의 테스트가 끝날 때 마다 해당 테스트에서 추가한 데이터를 삭제해야 함

**테스트에서 매우 중요한 원칙**
- 테스트는 다른 테스트와 격리해야 함
- 테스트는 반복해서 실행할 수 있어야 함

물론 테스트가 끝날 때 마다 추가한 데이터에 `DELETE SQL`을 사용해도 되겠지만, 이 방법도 궁극적인 해결책은 아님. 만약 테스트 과정에서 데이터를 이미 추가했는데, 테스트가 실행되는 도중에 예외가 발생하거나 애플리케이션이 종료되어 버려서 테스트 종료 시점에 `DELETE SQL`을 호출하지 못할 수도 있음

## 데이터 롤백

### 트랜잭션과 롤백 전략
테스트가 끝나고 나서 트랜잭션을 강제로 롤백해버리면 데이터가 깔끔하게 제거됨
테스트를 하면서 데이터를 이미 저장했는데, 중간에 테스트가 실패해서 롤백을 호출하지 못해도 괜찮음
트랜잭션을 커밋하지 않았기 때문에 데이터베이스에 해당 데이터가 반영되지 않음
이렇게 트랜잭션을 활용하면 테스트가 끝나고 나서 데이터를 깔끔하게 원래 상태로 되돌릴 수 있음

예를 들어서 다음 순서와 같이 각각의 테스트 실행 직전에 트랜잭션을 시작하고, 각각의 테스트 실행 직후에 트랜잭션을 롤백해야 함. 그래야 다음 테스트에 데이터로 인한 영향을 주지 않음

```
1. 트랜잭션 시작
2. 테스트 A 실행
3. 트랜잭션 롤백

4. 트랜잭션 시작
5. 테스트 B 실행
6. 트랜잭션 롤백
```

테스트는 각각의 테스트 실행 전 후로 동작하는 `@BeforeEach`, `@AfterEach`라는 편리한 기능을 제공

**테스트에 직접 트랜잭션 추가**
```java
@SpringBootTest
class ItemRepositoryTest {
  
    @Autowired
    ItemRepository itemRepository;
  
    //트랜잭션 관련 코드
    @Autowired
    PlatformTransactionManager transactionManager;
    TransactionStatus status;
  
    @BeforeEach
    void beforeEach() {
        //트랜잭션 시작
        status = transactionManager.getTransaction(new DefaultTransactionDefinition());
    }
  
    @AfterEach
    void afterEach() {
        //MemoryItemRepository 의 경우 제한적으로 사용
        if (itemRepository instanceof MemoryItemRepository) {
            ((MemoryItemRepository) itemRepository).clearStore();
        }
        //트랜잭션 롤백
        transactionManager.rollback(status);
    }
    //...
}
```

- 트랜잭션 관리자는 `PlatformTransactionManager`를 주입 받아서 사용. 참고로 스프링 부트는 자동으로 적절한 트랜잭션 매니저를 스프링 빈으로 등록
- `@BeforeEach`: 각각의 테스트 케이스를 실행하기 직전에 호출됨. 따라서 여기서 트랜잭션을 시작하면 각각의 테스트를 트랜잭션 범위 안에서 실행할 수 있음
  - `transactionManager.getTransaction(new DefaultTransactionDefinition())`로 트랜잭션을 시작
- `@AfterEach`: 각각의 테스트 케이스가 완료된 직후에 호출됨. 따라서 여기서 트랜잭션을 롤백하면 데이터를 트랜잭션 실행 전 상태로 복구할 수 있음
  - `transactionManager.rollback(status)`로 트랜잭션을 롤백
- 테스트를 실행하기 전에 먼저 테스트에 영향을 주지 않도록 `testcase` 데이터베이스에 접근해서 기존 데이터를 깔끔하게 삭제

**모든 ITEM 데이터 삭제**
`delete from item`

**데이터가 모두 삭제되었는지 확인**
`SELECT * FROM ITEM`

**ItemRepositoryTest 실행**
이제 `ItemRepositoryTest`의 테스트를 여러번 반복해서 실행해도 테스트가 성공하는 것을 확인할 수 있음

## @Transactional
## 임베디드 모드 DB
## 스프링 부트와 임베디드 모드
정리