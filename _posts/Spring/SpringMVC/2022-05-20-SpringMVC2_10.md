---
layout: post
title: 스프링 MVC 2편 - 백엔드 웹 개발 활용 기술 - 10. 스프링 타입 컨버터
tags: [Spring, SpringMVC2, UF]
permalink: /docs/Spring/SpringMVC2_10
date: 2022-05-20 23:12:00
---
# 10. 스프링 타입 컨버터

## 스프링 타입 컨버터 소개

**스프링의 타입 변환 적용 예**
- 스프링 MVC 요청 파라미터
- `@RequestParam`, `@ModelAttribute`, `@PathVariable`
- `@Value` 등으로 YML 정보 읽기
- XML에 넣은 스프링 빈 정보를 변환
- 뷰를 렌더링 할 때

**컨버터 인터페이스**
```java
public interface Converter<S, T> {
  T convert(S source);
}
```

- 스프링에 추가적인 타입 변환이 필요하면 이 컨버터 인터페이스를 구현해서 등록
- 컨버터 인터페이스는 모든 타입에 적용 가능. 필요하면 X → Y 타입으로 변환하는 컨버터 인터페이스를 만들고, 또 Y → X 타입으로 변환하는 컨버터 인터페이스를 만들어서 등록
> 참고
> 과거에는 `PropertyEditor`라는 것으로 타입을 변환했다. `PropertyEditor`는 동시성 문제가 있어서 타입을 변환할 때 마다 객체를 계속 생성해야 하는 단점이 있다. 지금은 `Converter`의 등장으로 해당
문제들이 해결되었고, 기능 확장이 필요하면 `Converter`를 사용하면 된다.

## 타입 컨버터 - Converter

타입 컨버터를 사용하려면 `org.springframework.core.convert.converter.Converter`
인터페이스를 구현하면 됨

**StringToIntegerConverter - 문자를 숫자로 변환하는 타입 컨버터**
```java
@Slf4j
public class StringToIntegerConverter implements Converter<String, Integer> {
  
    @Override
    public Integer convert(String source) {
        log.info("convert source={}", source);
        return Integer.valueOf(source);
    }
}
```

- `String` → `Integer`로 변환하기 때문에 소스가 `String`
- 이 문자를 `Integer.valueOf(source)`를 사용해서 숫자로 변경한 다음에 변경된 숫자를 반환

**IntegerToStringConverter - 숫자를 문자로 변환하는 타입 컨버터**
```java
@Slf4j
public class IntegerToStringConverter implements Converter<Integer, String> {
    @Override
    public String convert(Integer source) {
        log.info("convert source={}", source);
        return String.valueOf(source);
    }
}
```
- 숫자가 입력되기 때문에 소스가 `Integer`
- `String.valueOf(source)`를 사용해서 문자로 변경한 다음 변경된 문자를 반환

**ConverterTest - 타입 컨버터 테스트 코드**
```java
class ConverterTest {
  
    @Test
    void stringToInteger() {
        StringToIntegerConverter converter = new StringToIntegerConverter();
        Integer result = converter.convert("10");
        assertThat(result).isEqualTo(10);
    }
  
    @Test
    void integerToString() {
        IntegerToStringConverter converter = new IntegerToStringConverter();
        String result = converter.convert(10);
        assertThat(result).isEqualTo("10");
    }
}
```

**사용자 정의 타입 컨버터**
`127.0.0.1:8080`과 같은 IP, PORT를 입력하면 IpPort 객체로 변환하는 컨버터

**IpPort**
```java
@Getter
@EqualsAndHashCode
public class IpPort {
  
    private String ip;
    private int port;
  
    public IpPort(String ip, int port) {
        this.ip = ip;
        this.port = port;
    }
}
```

- 롬복의 `@EqualsAndHashCode`를 넣으면 모든 필드를 사용해서 `equals()`, `hashcode()`를 생성
- 따라서 모든 필드의 값이 같다면 `a.equals(b)`의 결과가 참

**StringToIpPortConverter - 컨버터**
```java
@Slf4j
public class StringToIpPortConverter implements Converter<String, IpPort> {
  
    @Override
    public IpPort convert(String source) {
        log.info("convert source={}", source);
        String[] split = source.split(":");
        String ip = split[0];
        int port = Integer.parseInt(split[1]);
      
        return new IpPort(ip, port);
    }
}
```

`127.0.0.1:8080` 같은 문자를 입력하면 `IpPort` 객체를 만들어 반환

**IpPortToStringConverter**
```java
@Slf4j
public class IpPortToStringConverter implements Converter<IpPort, String> {
  
    @Override
    public String convert(IpPort source) {
        log.info("convert source={}", source);
        return source.getIp() + ":" + source.getPort();
    }
}
```

`IpPort` 객체를 입력하면 `127.0.0.1:8080` 같은 문자를 반환

**ConverterTest - IpPort 컨버터 테스트 추가**
```java
@Test
void stringToIpPort() {
    StringToIpPortConverter converter = new StringToIpPortConverter();
    String source = "127.0.0.1:8080";
    IpPort result = converter.convert(source);
    assertThat(result).isEqualTo(new IpPort("127.0.0.1", 8080));
}
@Test
void ipPortToString() {
    IpPortToStringConverter converter = new IpPortToStringConverter();
    IpPort source = new IpPort("127.0.0.1", 8080);
    String result = converter.convert(source);
    assertThat(result).isEqualTo("127.0.0.1:8080");
}
```

- 이렇게 타입 컨버터를 하나하나 직접 사용하면, 개발자가 직접 컨버팅 하는 것과 큰 차이가 없음
- 타입 컨버터를 등록하고 관리하면서 편리하게 변환 기능을 제공하는 역할을 하는 무언가가 필요

> 참고
> 스프링은 용도에 따라 다양한 방식의 타입 컨버터를 제공한다.
>
> `Converter` → 기본 타입 컨버터
> `ConverterFactory` → 전체 클래스 계층 구조가 필요할 때
> `GenericConverter` → 정교한 구현, 대상 필드의 애노테이션 정보 사용 가능
> `ConditionalGenericConverter` → 특정 조건이 참인 경우에만 실행
>
> 자세한 내용은 공식 문서를 참고하자.
> https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#coreconvert

> 참고
> 스프링은 문자, 숫자, 불린, Enum등 일반적인 타입에 대한 대부분의 컨버터를 기본으로 제공한다. IDE에서 `Converter`, `ConverterFactory`, `GenericConverter` 의 구현체를 찾아보면 수많은 컨버터를 확인할 수 있다.

## 컨버전 서비스 - ConversionService

스프링은 개별 컨버터를 모아두고 그것들을 묶어서 편리하게 사용할 수 있는 기능을 제공하는데, 이것이 바로 컨버전 서비스( `ConversionService` )

**ConversionService 인터페이스**
```java
package org.springframework.core.convert;

import org.springframework.lang.Nullable;

public interface ConversionService {
  
    boolean canConvert(@Nullable Class<?> sourceType, Class<?> targetType);
    boolean canConvert(@Nullable TypeDescriptor sourceType, TypeDescriptor targetType);
  
    <T> T convert(@Nullable Object source, Class<T> targetType);
    Object convert(@Nullable Object source, @Nullable TypeDescriptor sourceType, TypeDescriptor targetType);
}
```

**ConversionServiceTest - 컨버전 서비스 테스트 코드**
```java
public class ConversionServiceTest {
  
    @Test
    void conversionService() {
      
        //등록
        DefaultConversionService conversionService = new
        DefaultConversionService();
        conversionService.addConverter(new StringToIntegerConverter());
        conversionService.addConverter(new IntegerToStringConverter());
        conversionService.addConverter(new StringToIpPortConverter());
        conversionService.addConverter(new IpPortToStringConverter());
      
        //사용
        assertThat(conversionService.convert("10", Integer.class)).isEqualTo(10);
        assertThat(conversionService.convert(10, String.class)).isEqualTo("10");
        IpPort ipPort = conversionService.convert("127.0.0.1:8080", IpPort.class);
        assertThat(ipPort).isEqualTo(new IpPort("127.0.0.1", 8080));
      
        String ipPortString = conversionService.convert(new IpPort("127.0.0.1", 8080), String.class);
        assertThat(ipPortString).isEqualTo("127.0.0.1:8080");
    }
}
```

`DefaultConversionService`는 `ConversionService` 인터페이스를 구현했는데, 추가로 컨버터를 등록하는 기능도 제공

**등록과 사용 분리**
- 컨버터를 등록할 때는 `StringToIntegerConverter` 같은 타입 컨버터를 명확하게 알아야 함
- 반면에 컨버터를 사용하는 입장에서는 타입 컨버터를 전혀 몰라도 됨
- 타입 컨버터들은 모두 컨버전 서비스 내부에 숨어서 제공됨. 따라서 타입을 변환을 원하는 사용자는 컨버전 서비스 인터페이스에만 의존하면 됨. 
- 컨버전 서비스를 등록하는 부분과 사용하는 부분을 분리하고 의존관계 주입을 사용해야 함

**컨버전 서비스 사용**
`Integer value = conversionService.convert("10", Integer.class)`

**인터페이스 분리 원칙 - ISP(Interface Segregation Principal)**
인터페이스 분리 원칙은 클라이언트가 자신이 이용하지 않는 메서드에 의존하지 않아야 함

`DefaultConversionService`는 다음 두 인터페이스를 구현
- `ConversionService` : 컨버터 사용에 초점
- `ConverterRegistry` : 컨버터 등록에 초점

이렇게 인터페이스를 분리하면 컨버터를 사용하는 클라이언트와 컨버터를 등록하고 관리하는 클라이언트의 관심사를 명확하게 분리할 수 있음. 특히 컨버터를 사용하는 클라이언트는 `ConversionService`만 의존하면 되므로, 컨버터를 어떻게 등록하고 관리하는지는 전혀 몰라도 됨. 결과적으로 컨버터를 사용하는 클라이언트는 꼭 필요한 메서드만 알게 됨. 

ISP 참고: https://ko.wikipedia.org/wiki/%EC%9D%B8%ED%84%B0%ED%8E%98%EC%9D%B4%EC%8A%A4_%EB%B6%84%EB%A6%AC_%EC%9B%90%EC%B9%99

스프링은 `@RequestParam` 같은 곳에서 `ConversionService` 를 사용해서 타입을 변환

## 스프링에 Converter 적용하기

**WebConfig - 컨버터 등록**
```java
@Configuration
public class WebConfig implements WebMvcConfigurer {
  
    @Override
    public void addFormatters(FormatterRegistry registry) {
        registry.addConverter(new StringToIntegerConverter());
        registry.addConverter(new IntegerToStringConverter());
        registry.addConverter(new StringToIpPortConverter());
        registry.addConverter(new IpPortToStringConverter());
    }
}
```

- 스프링은 내부에서 `ConversionService`를 제공
- 개발자는 `WebMvcConfigurer`가 제공하는 `addFormatters()`를 사용해서 추가하고 싶은 컨버터를 등록
- 이렇게 하면 스프링은 내부에서 사용하는 `ConversionService`에 컨버터를 추가
- 스프링은 내부에서 수많은 기본 컨버터들을 제공
- 컨버터를 추가하면 추가한 컨버터가 기본 컨버터 보다 높은 우선순위


**HelloController - 추가**
```java
@GetMapping("/ip-port")
public String ipPort(@RequestParam IpPort ipPort) {
    System.out.println("ipPort IP = " + ipPort.getIp());
    System.out.println("ipPort PORT = " + ipPort.getPort());
    return "ok";
}
```

**실행 로그**
```
StringToIpPortConverter : convert source=127.0.0.1:8080
ipPort IP = 127.0.0.1
ipPort PORT = 8080
```

`?ipPort=127.0.0.1:8080` 쿼리 스트링이 `@RequestParam IpPort ipPort` 에서 객체 타입으로 잘\변환됨

**처리 과정**
`@RequestParam`은 `@RequestParam`을 처리하는 `ArgumentResolver`인
`RequestParamMethodArgumentResolver`에서 `ConversionService`를 사용해서 타입을 변환
부모 클래스와 다양한 외부 클래스를 호출하는 등 복잡한 내부 과정을 거치기 때문에 대략 이렇게 처리되는 것으로 이해해도 충분

## 뷰 템플릿에 컨버터 적용하기

**ConverterController**
```java
@Controller
public class ConverterController {
  
    @GetMapping("/converter-view")
    public String converterView(Model model) {
        model.addAttribute("number", 10000);
        model.addAttribute("ipPort", new IpPort("127.0.0.1", 8080));
        return "converter-view";
    }
}
```

`Model`에 숫자 `10000`와 `ipPort`객체를 담아서 뷰 템플릿에 전달

`resources/templates/converter-view.html`
```html
<!DOCTYPE html>
<html xmlns:th="http://www.thymeleaf.org">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
</head>
<body>
    <ul>
        <li>${number}: <span th:text="${number}" ></span></li>
        <li>${{number}}: <span th:text="${{number}}" ></span></li>
        <li>${ipPort}: <span th:text="${ipPort}" ></span></li>
        <li>${{ipPort}}: <span th:text="${{ipPort}}" ></span></li>
    </ul>
</body>
</html>
```

타임리프는` ${{...}}` 를 사용하면 자동으로 컨버전 서비스를 사용해서 변환된 결과를 출력. 물론 스프링과 통합 되어서 스프링이 제공하는 컨버전 서비스를 사용하므로, 개발자가 등록한 컨버터들을 사용할 수 있음

- 변수 표현식 : `${...}`
- 컨버전 서비스 적용 : `${{...}}`

- `${{number}}` : 뷰 템플릿은 데이터를 문자로 출력. 따라서 컨버터를 적용하게 되면 `Integer` 타입인 `10000`을 `String` 타입으로 변환하는 컨버터인 `IntegerToStringConverter`를 실행하게 된다. 이 부분은 컨버터를 실행하지 않아도 타임리프가 숫자를 문자로 자동으로 변환하기 때문에 컨버터를 적용할 때와 하지 않을 때가 같음
- `${{ipPort}}`: 뷰 템플릿은 데이터를 문자로 출력. 따라서 컨버터를 적용하게 되면 `IpPort` 타입을 `String` 타입으로 변환해야 하므로 `IpPortToStringConverter`가 적용. 그 결과 `127.0.0.1:8080`가 출력
- 타임리프의 `th:field`는 `id`, `name`을 출력하는 등 다양한 기능이 있는데, 여기에 컨버전 서비스도 함께 적용

## 포맷터 - Formatter

## 포맷터를 지원하는 컨버전 서비스

## 포맷터 적용하기

## 스프링이 제공하는 기본 포맷터