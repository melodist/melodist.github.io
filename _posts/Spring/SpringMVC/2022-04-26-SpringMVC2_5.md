---
layout: post
title: 스프링 MVC 2편 - 백엔드 웹 개발 활용 기술 - 5. 검증2 - Bean Validation
tags: [Spring, SpringMVC2, UF]
permalink: /docs/Spring/SpringMVC2_5
date: 2022-04-26 23:20:00
---
# 검증2 - Bean Validation

## Bean Validation 

### 소개

- 일반적인 검증 로직을 모든 프로젝트에 적용할 수 있도록 공통화, 표준화
- Bean Validation은 특정한 구현체가 아니라 Bean Validation 2.0(JSR-380)이라는 기술 표준
- 쉽게 이야기해서 검증 애노테이션과 여러 인터페이스의 모음
- Bean Validation을 구현한 기술중에 일반적으로 사용하는 구현체는 하이버네이트 Validator

**하이버네이트 Validator 관련 링크**
- 공식 사이트: http://hibernate.org/validator/
- 공식 메뉴얼: https://docs.jboss.org/hibernate/validator/6.2/reference/en-US/html_single/
- 검증 애노테이션 모음: https://docs.jboss.org/hibernate/validator/6.2/reference/en-US/html_single/#validator-defineconstraints-spec

### 시작

**의존관계 추가**
```
implementation 'org.springframework.boot:spring-boot-starter-validation'
```

`spring-boot-starter-validation` 의존관계를 추가하면 라이브러리가 추가

**Jakarta Bean Validation**
`jakarta.validation-api` : Bean Validation 인터페이스
`hibernate-validator`: 구현체

**검증 애노테이션**
`@NotBlank`: 빈값 + 공백만 있는 경우를 허용하지 않음
`@NotNull`: `null`을 허용하지 않음
`@Range(min = 1000, max = 1000000)`: 범위 안의 값이어야 함
`@Max(9999)` : 최대 9999까지만 허용

> 참고
> `javax.validation.constraints.NotNull`
> `org.hibernate.validator.constraints.Range`
>
> `javax.validation`으로 시작하면 특정 구현에 관계없이 제공되는 표준 인터페이스이고, `org.hibernate.validator`로 시작하면 하이버네이트 validator 구현체를 사용할 때만 제공되는 검증 기능이다. 실무에서 대부분 하이버네이트 validator를 사용하므로 자유롭게 사용해도 된다.

**검증기 생성**
스프링과 통합하면 이런 코드를 작성하지 않으므로 참고만 할 것
```java
ValidatorFactory factory = Validation.buildDefaultValidatorFactory();
Validator validator = factory.getValidator();
```

**검증 실행**
- 검증 대상( `item` )을 직접 검증기에 넣고 그 결과를 받음
- `Set`에는 `ConstraintViolation` 이라는 검증 오류가 담김
- `ConstraintViolation` 출력 결과를 보면, 검증 오류가 발생한 객체, 필드, 메시지 정보등 다양한 정보를 확인할 수 있음
- 결과가 비어있으면 검증 오류 없음
  ```java
Set<ConstraintViolation<Item>> violations = validator.validate(item);
  ```

### 스프링 적용

**스프링 MVC는 어떻게 Bean Validator를 사용?**
스프링 부트가 `spring-boot-starter-validation` 라이브러리를 넣으면 자동으로 Bean Validator를 인지하고 스프링에 통합

**스프링 부트는 자동으로 글로벌 Validator로 등록**
- `LocalValidatorFactoryBean`을 글로벌 Validator로 등록
- 이 Validator는 `@NotNull`같은 애노테이션을 보고 검증을 수행
- 이렇게 글로벌 Validator가 적용되어 있기 때문에, `@Valid`, `@Validated`만 적용하면 됨
- 검증 오류가 발생하면 `FieldError`, `ObjectError`를 생성해서 BindingResult 에 포함

**주의!**
직접 글로벌 Validator를 직접 등록하면 스프링 부트는 Bean Validator를 글로벌
`Validator`로 등록하지 않음

**참고**
> 검증시 `@Validated`, `@Valid` 둘다 사용가능
> `javax.validation.@Valid` 를 사용하려면 `build.gradle` 의존관계 추가가 필요하다.
> `implementation 'org.springframework.boot:spring-boot-starter-validation'`
> `@Validated`는 스프링 전용 검증 애노테이션이고, `@Valid`는 자바 표준 검증 애노테이션이다. 둘중
아무거나 사용해도 동일하게 작동하지만, `@Validated`는 내부에 `groups`라는 기능을 포함하고 있다. 

**검증 순서**
1. `@ModelAttribute` 각각의 필드에 타입 변환 시도
  1. 성공하면 다음으로
  2. 실패하면 `typeMismatch`로 `FieldError` 추가
2. `Validator` 적용

**바인딩에 성공한 필드만 Bean Validation 적용**
- BeanValidator는 바인딩에 실패한 필드는 BeanValidation을 적용하지 않음
- 타입 변환에 성공해서 바인딩에 성공한 필드여야 BeanValidation 적용이 의미 있음
- 일단 모델 객체에 바인딩 받는 값이 정상으로 들어와야 검증도 의미가 있음

`@ModelAttribute` → 각각의 필드 타입 변환시도 → 변환에 성공한 필드만 BeanValidation 적용

**예)**
- `itemName`에 문자 "A" 입력 → 타입 변환 성공 → `itemName` 필드에 BeanValidation 적용
- `price`에 문자 "A" 입력 → "A"를 숫자 타입 변환 시도 실패 → typeMismatch FieldError 추가 → `price`필드는 BeanValidation 적용 X

### 에러 코드

### 오브젝트 오류

### 수정에 적용

### 한계

### groups

### HTTP 메시지 컨버터

## Form 전송 객체 분리

### 소개

### 개발