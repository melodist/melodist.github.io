---
layout: post
title: 스프링 MVC 2편 - 백엔드 웹 개발 활용 기술 - 11. 파일 업로드
tags: [Spring, SpringMVC2, UF]
permalink: /docs/Spring/SpringMVC2_11
date: 2022-05-26 22:39:00
---
# 11. 파일 업로드

## 파일 업로드 소개

**HTML 폼 전송 방식**
- `application/x-www-form-urlencoded`
- `multipart/form-data`
- 
**application/x-www-form-urlencoded 방식**

![파일 업로드 - 01  x-www-form-urlencoded](https://user-images.githubusercontent.com/52024566/170501228-2010da78-b86d-48ed-8a05-850a43ea4196.png)

- `application/x-www-form-urlencoded` 방식은 HTML 폼 데이터를 서버로 전송하는 가장 기본적인 방법
- Form 태그에 별도의 `enctype` 옵션이 없으면 웹 브라우저는 요청 HTTP 메시지의 헤더에 다음 내용을 추가
`Content-Type: application/x-www-form-urlencoded`
- 그리고 폼에 입력한 전송할 항목을 HTTP Body에 문자로 `username=kim&age=20`와 같이 `&`로 구분해서 전송
- 파일을 업로드하려면 파일은 문자가 아니라 바이너리 데이터를 전송해야 하므로 문자를 전송하는 이 방식으로 파일을 전송하기는 어려움. 
- 그리고 또 한가지 문제가 더 있는데, 보통 폼을 전송할 때 파일만 전송하는 것이 아님

```
- 이름
- 나이
- 첨부파일
```

이름과 나이는 문자로 전송하고, 첨부파일은 바이너리로 전송해야 함. 여기에서 문제가 발생한다. 문자와 바이너리를 동시에 전송해야 하는 상황

이 문제를 해결하기 위해 HTTP는 `multipart/form-data`라는 전송 방식을 제공

**multipart/form-data 방식**

![파일 업로드 - 02  form-data](https://user-images.githubusercontent.com/52024566/170501238-45c44e55-862e-4ae3-8734-3288ae7d46b8.png)

- 이 방식을 사용하려면 Form 태그에 별도의 `enctype="multipart/form-data"`를 지정해야 함
- `multipart/form-data` 방식은 다른 종류의 여러 파일과 폼의 내용 함께 전송할 수 있음
- 폼의 입력 결과로 생성된 HTTP 메시지를 보면 각각의 전송 항목이 구분됨. `Content-Disposition`이라는 항목별 헤더가 추가되어 있고 여기에 부가 정보가 있다. 예제에서는 `username`, `age`, `file1`이 각각 분리되어 있고, 폼의 일반 데이터는 각 항목별로 문자가 전송되고, 파일의 경우 파일 이름과 `Content-Type`이 추가되고 바이너리 데이터가 전송됨

**Part**
`multipart/form-data`는 `application/x-www-form-urlencoded`와 비교해서 매우 복잡하고 각각의 부분( `Part`)로 나누어져 있음. 그렇다면 이렇게 복잡한 HTTP 메시지를 서버에서 어떻게 사용할 수 있을까?

## 서블릿과 파일 업로드

**ServletUploadControllerV1**
```java
@Slf4j
@Controller
@RequestMapping("/servlet/v1")
public class ServletUploadControllerV1 {
  
    @GetMapping("/upload")
    public String newFile() {
        return "upload-form";
    }
  
    @PostMapping("/upload")
    public String saveFileV1(HttpServletRequest request) throws ServletException, IOException {
        log.info("request={}", request);
      
        String itemName = request.getParameter("itemName");
        log.info("itemName={}", itemName);
      
        Collection<Part> parts = request.getParts();
        log.info("parts={}", parts);
      
        return "upload-form";
    }
}
```

`request.getParts()`: `multipart/form-data` 전송 방식에서 각각 나누어진 부분을 받아서 확인할 수 있음

테스트를 진행하기 전에 먼저 다음 옵션들을 추가
`application.properties`
```
logging.level.org.apache.coyote.http11=debug
```
이 옵션을 사용하면 HTTP 요청 메시지를 확인할 수 있음

실행해보면 `logging.level.org.apache.coyote.http11` 옵션을 통한 로그에서 `multipart/formdata` 방식으로 전송된 것을 확인할 수 있음
**결과 로그**
```
Content-Type: multipart/form-data; boundary=----xxxx

------xxxx
Content-Disposition: form-data; name="itemName"

Spring
------xxxx
Content-Disposition: form-data; name="file"; filename="test.data"
Content-Type: application/octet-stream

sdklajkljdf...
```

### 멀티파트 사용 옵션

**업로드 사이즈 제한**
```
spring.servlet.multipart.max-file-size=1MB
spring.servlet.multipart.max-request-size=10MB
```

큰 파일을 무제한 업로드하게 둘 수는 없으므로 업로드 사이즈를 제한
사이즈를 넘으면 예외( `SizeLimitExceededException` )가 발생
`max-file-size`: 파일 하나의 최대 사이즈, 기본 1MB
`max-request-size`: 멀티파트 요청 하나에 여러 파일을 업로드 할 수 있는데, 그 전체 합. 기본 10MB

**spring.servlet.multipart.enabled 끄기**
`spring.servlet.multipart.enabled=false`

**결과 로그**
```
request=org.apache.catalina.connector.RequestFacade@xxx
itemName=null
parts=[]
```

- 멀티파트는 일반적인 폼 요청인 `application/x-www-form-urlencoded` 보다 훨씬 복잡
- `spring.servlet.multipart.enabled` 옵션을 끄면 서블릿 컨테이너는 멀티파트와 관련된 처리를 하지 않음
- 그래서 결과 로그를 보면 `request.getParameter("itemName")`, `request.getParts()`의 결과가 비어 있음

**spring.servlet.multipart.enabled 켜기**
`spring.servlet.multipart.enabled=true` (기본 true)
이 옵션을 켜면 스프링 부트는 서블릿 컨테이너에게 멀티파트 데이터를 처리하라고 설정 참고로 기본값은 `true`이다.

```
request=org.springframework.web.multipart.support.StandardMultipartHttpServletRequest
itemName=Spring
parts=[ApplicationPart1, ApplicationPart2]
```

`request.getParameter("itemName")`의 결과도 잘 출력되고, `request.getParts()`에도 요청한 두 가지 멀티파트의 부분 데이터가 포함된 것을 확인할 수 있음. 이 옵션을 켜면 복잡한 멀티파트 요청을
처리해서 사용할 수 있게 제공

로그를 보면 `HttpServletRequest` 객체가 `RequestFacade` → `StandardMultipartHttpServletRequest`로 변한 것을 확인할 수 있음

> 참고
> `spring.servlet.multipart.enabled` 옵션을 켜면 스프링의 `DispatcherServlet` 에서 멀티파트 리졸버( `MultipartResolver` )를 실행
> 멀티파트 리졸버는 멀티파트 요청인 경우 서블릿 컨테이너가 전달하는 일반적인 `HttpServletRequest`를 `MultipartHttpServletRequest`로 변환해서 반환
> `MultipartHttpServletRequest`는 `HttpServletRequest`의 자식 인터페이스이고, 멀티파트와 관련된 추가 기능을 제공
>
> 스프링이 제공하는 기본 멀티파트 리졸버는 `MultipartHttpServletRequest` 인터페이스를 구현한 `StandardMultipartHttpServletRequest`를 반환
> 이제 컨트롤러에서 `HttpServletRequest` 대신에 `MultipartHttpServletRequest`를 주입받을 수 있는데, 이것을 사용하면 멀티파트와 관련된 여러가지 처리를 편리하게 할 수 있음. 그런데  `MultipartFile`이라는 것을 사용하는 것이 더 편하기 때문에 `MultipartHttpServletRequest`를 잘 사용하지 않음.

서블릿이 제공하는 `Part` 에 대해 알아보고 실제 파일도 서버에 업로드

**application.properties**
```
file.dir=파일 업로드 경로 설정(예): /Users/kimyounghan/study/file/
```

**주의**
1. 꼭 해당 경로에 실제 폴더를 미리 생성
2. `application.properties`에서 설정할 때 마지막에 `/` (슬래시)가 포함된 것에 주의

**ServletUploadControllerV2**
```java
@Slf4j
@Controller
@RequestMapping("/servlet/v2")
public class ServletUploadControllerV2 {
  
    @Value("${file.dir}")
    private String fileDir;
  
    @GetMapping("/upload")
    public String newFile() {
      return "upload-form";
    }
  
    @PostMapping("/upload")
    public String saveFileV1(HttpServletRequest request) throws ServletException, IOException {
        log.info("request={}", request);
      
        String itemName = request.getParameter("itemName");
        log.info("itemName={}", itemName);
      
        Collection<Part> parts = request.getParts();
        log.info("parts={}", parts);
      
        for (Part part : parts) {
            log.info("==== PART ====");
            log.info("name={}", part.getName());
            Collection<String> headerNames = part.getHeaderNames();
            for (String headerName : headerNames) {
                log.info("header {}: {}", headerName,
                part.getHeader(headerName));
            }
          
            //편의 메서드
            //content-disposition; filename
            log.info("submittedFileName={}", part.getSubmittedFileName());
            log.info("size={}", part.getSize()); //part body size
          
            //데이터 읽기
            InputStream inputStream = part.getInputStream();
            String body = StreamUtils.copyToString(inputStream, StandardCharsets.UTF_8);
            log.info("body={}", body);
          
            //파일에 저장하기
            if (StringUtils.hasText(part.getSubmittedFileName())) {
                String fullPath = fileDir + part.getSubmittedFileName();
                log.info("파일 저장 fullPath={}", fullPath);
                part.write(fullPath);
            }
        }
      
        return "upload-form";
    }
}
```

```java
@Value("${file.dir}")
private String fileDir;
```
`application.properties`에서 설정한 `file.dir`의 값을 주입

멀티파트 형식은 전송 데이터를 하나하나 각각 부분( `Part` )으로 나누어 전송한다. `parts`에는 이렇게 나누어진 데이터가 각각 담김.
서블릿이 제공하는 `Part` 는 멀티파트 형식을 편리하게 읽을 수 있는 다양한 메서드를 제공

**Part 주요 메서드**
`part.getSubmittedFileName()`: 클라이언트가 전달한 파일명
`part.getInputStream()`: Part의 전송 데이터를 읽음
`part.write(...)`: Part를 통해 전송된 데이터를 저장

**결과 로그**
```
==== PART ====
name=itemName
header content-disposition: form-data; name="itemName"
submittedFileName=null
size=7
body=상품A
==== PART ====
name=file
header content-disposition: form-data; name="file"; filename="스크린샷.png"
header content-type: image/png
submittedFileName=스크린샷.png
size=112384
body=qwlkjek2ljlese...
파일 저장 fullPath=/Users/kimyounghan/study/file/스크린샷.png
```

> **참고**
> 큰 용량의 파일을 업로드를 테스트 할 때는 로그가 너무 많이 남아서 다음 옵션을 끄는 것이 좋음
> `logging.level.org.apache.coyote.http11=debug`
> 다음 부분도 파일의 바이너리 데이터를 모두 출력하므로 끄는 것이 좋음
> `log.info("body={}", body);`

서블릿이 제공하는 `Part`는 편하기는 하지만, `HttpServletRequest`를 사용해야 하고, 추가로 파일 부분만 구분하려면 여러가지 코드를 넣어야 함

## 스프링과 파일 업로드

## 예제로 구현하는 파일 업로드, 다운로드