---
layout: post
title: 스프링 MVC 2편 - 백엔드 웹 개발 활용 기술 - 9. API 예외 처리
tags: [Spring, SpringMVC2, UF]
permalink: /docs/Spring/SpringMVC2_9
date: 2022-05-12 23:37:00
---
# 9. API 예외 처리

## 스프링 부트 기본 오류 처리

**BasicErrorController 코드**
```java
@RequestMapping(produces = MediaType.TEXT_HTML_VALUE)
public ModelAndView errorHtml(HttpServletRequest request, HttpServletResponse response) {}

@RequestMapping
public ResponseEntity<Map<String, Object>> error(HttpServletRequest request) {}
```

- `errorHtml()`: `produces = MediaType.TEXT_HTML_VALUE`: 클라이언트 요청의 Accept 해더 값이 `text/html`인 경우에는 `errorHtml()`을 호출해서 view를 제공
- `error()`: 그외 경우에 호출되고 `ResponseEntity`로 HTTP Body에 JSON 데이터를 반환

스프링 부트는 `BasicErrorController`가 제공하는 기본 정보들을 활용해서 오류 API를 생성
다음 옵션들을 설정하면 더 자세한 오류 정보를 추가
- `server.error.include-binding-errors=always`
- `server.error.include-exception=true`
- `server.error.include-message=always`
- `server.error.include-stacktrace=always`
물론 오류 메시지는 이렇게 막 추가하면 보안상 위험할 수 있으므로 간결한 메시지만 노출하고, 로그를 통해서 확인

### Html 페이지 vs API 오류

`BasicErrorController`를 확장하면 JSON 메시지도 변경할 수 있음. 그런데 API 오류는 조금 뒤에 설명할 `@ExceptionHandler`가 제공하는 기능을 사용하는 것이 더 나은 방법이므로 지금은 `BasicErrorController`를 확장해서 JSON 오류 메시지를 변경할 수 있다 정도로만 이해

스프링 부트가 제공하는 `BasicErrorController`는 HTML 페이지를 제공하는 경우에는 매우 편리. 그런데 API 오류 처리는 다른 차원의 이야기로 API 마다, 각각의 컨트롤러나 예외마다 서로 다른 응답 결과를 출력해야 할 수도 있음. 예를 들어서 회원과 관련된 API에서 예외가 발생할 때 응답과, 상품과 관련된 API에서 발생하는 예외에 따라 그 결과가 달라질 수 있음.
결과적으로 매우 세밀하고 복잡하므로 이 방법은 HTML 화면을 처리할 때 사용하고, API는 오류 처리는 뒤에서 설명할 `@ExceptionHandler`를 사용

## HandlerExceptionResolver

**상태코드 변환**
`IllegalArgumentException`을 처리하지 못해서 컨트롤러 밖으로 넘어가는 일이 발생하면 HTTP 상태코드를 400으로 처리하고 싶은 경우

**ApiExceptionController - 수정**
```java
@GetMapping("/api/members/{id}")
public MemberDto getMember(@PathVariable("id") String id) {
  
    if (id.equals("ex")) {
        throw new RuntimeException("잘못된 사용자");
    }
  
    if (id.equals("bad")) {
        throw new IllegalArgumentException("잘못된 입력 값");
    }
  
    return new MemberDto(id, "hello " + id);
}
```

실행해보면 상태 코드가 500인 것을 확인할 수 있음
```json
{
    "status": 500,
    "error": "Internal Server Error",
    "exception": "java.lang.IllegalArgumentException",
    "path": "/api/members/bad"
}
```

**HandlerExceptionResolver**
스프링 MVC는 컨트롤러(핸들러) 밖으로 예외가 던져진 경우 예외를 해결하고, 동작을 새로 정의할 수 있는 방법을 제공함. 컨트롤러 밖으로 던져진 예외를 해결하고, 동작 방식을 변경하고 싶으면 `HandlerExceptionResolver`( `ExceptionResolver` ) 를 사용

**ExceptionResolver 적용 전**

![HandlerExceptionResolver 시작 - 01](https://user-images.githubusercontent.com/52024566/168305916-4e2aff26-3cee-48a8-82c4-ae7f71ad8568.png)

**ExceptionResolver 적용 후**

![HandlerExceptionResolver 시작 - 02](https://user-images.githubusercontent.com/52024566/168305922-0bfc9d2d-27bd-495d-a353-b85ae9ab26c9.png)

> 참고: `ExceptionResolver` 로 예외를 해결해도 `postHandle()`은 호출되지 않음

**HandlerExceptionResolver - 인터페이스**
```java
public interface HandlerExceptionResolver {
  
    ModelAndView resolveException(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex);
}
```

- `handler`: 핸들러(컨트롤러) 정보
- `Exception ex` : 핸들러(컨트롤러)에서 발생한 발생한 예외

**MyHandlerExceptionResolver**
```java
@Slf4j
public class MyHandlerExceptionResolver implements HandlerExceptionResolver {
  
    @Override
    public ModelAndView resolveException(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) {
      
        try {
            if (ex instanceof IllegalArgumentException) {
                log.info("IllegalArgumentException resolver to 400");
                response.sendError(HttpServletResponse.SC_BAD_REQUEST, ex.getMessage());
                return new ModelAndView();
            }
        } catch (IOException e) {
            log.error("resolver ex", e);
        }
      
        return null;
    }
}
```

- `ExceptionResolver`가 `ModelAndView`를 반환하는 이유는 마치 try, catch를 하듯이, `Exception`을 처리해서 정상 흐름 처럼 변경하는 것이 목적. 이름 그대로 `Exception`을 `Resolver`(해결)하는 것이 목적

여기서는 `IllegalArgumentException`이 발생하면 `response.sendError(400)`를 호출해서 HTTP 상태 코드를 400으로 지정하고, 빈 ModelAndView 를 반환

**반환 값에 따른 동작 방식**
`HandlerExceptionResolver`의 반환 값에 따른 `DispatcherServlet`의 동작 방식은 다음과 같음

- 빈 ModelAndView: `new ModelAndView()`처럼 빈 `ModelAndView`를 반환하면 뷰를 렌더링 하지 않고, 정상 흐름으로 서블릿이 리턴
- ModelAndView 지정: `ModelAndView`에 `View`, `Model` 등의 정보를 지정해서 반환하면 뷰를 렌더링
- null: `null`을 반환하면, 다음 `ExceptionResolver`를 찾아서 실행. 만약 처리할 수 있는 `ExceptionResolver`가 없으면 예외 처리가 안되고, 기존에 발생한 예외를 서블릿 밖으로 던짐

**ExceptionResolver 활용**
- 예외 상태 코드 변환
  - 예외를 `response.sendError(xxx)` 호출로 변경해서 서블릿에서 상태 코드에 따른 오류를 처리하도록 위임
  - 이후 WAS는 서블릿 오류 페이지를 찾아서 내부 호출, 예를 들어서 스프링 부트가 기본으로 설정한 `/error`가 호출됨
- 뷰 템플릿 처리
  - `ModelAndView`에 값을 채워서 예외에 따른 새로운 오류 화면 뷰 렌더링 해서 고객에게 제공
- API 응답 처리
  - `response.getWriter().println("hello");`처럼 HTTP 응답 바디에 직접 데이터를 넣어주는 것도 가능. 여기에 JSON 으로 응답하면 API 응답 처리가 가능

**WebConfig - 수정**
`WebMvcConfigurer`를 통해 등록
```java
/**
* 기본 설정을 유지하면서 추가
*/
@Override
public void extendHandlerExceptionResolvers(List<HandlerExceptionResolver> resolvers) {
    resolvers.add(new MyHandlerExceptionResolver());
}
```

`configureHandlerExceptionResolvers(..)`를 사용하면 스프링이 기본으로 등록하는 `ExceptionResolver`가 제거되므로 주의, `extendHandlerExceptionResolvers`를 사용

## 스프링이 제공하는 ExceptionResolver

## @ExceptionHandler

## @ControllerAdvice