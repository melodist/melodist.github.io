---
layout: post
title: 스프링 MVC 2편 - 백엔드 웹 개발 활용 기술 - 4. 검증1 - Validation
tags: [Spring, SpringMVC2, UF]
permalink: /docs/Spring/SpringMVC2_4
date: 2022-04-19 23:55:00
---
# 검증1 - Validation

## 검증 직접 처리

![검증 직접 처리 - 소개 - 01](https://user-images.githubusercontent.com/52024566/164251496-7cd8c88a-f13f-4702-a159-3895bba39ef7.png)

1. 사용자가 상품 등록 폼에서 정상 범위의 데이터 입력
2. 서버에서 검증 로직 통과하고 상품 저장
3. 상품 상세 화면으로 리다이렉트

![검증 직접 처리 - 소개 - 02](https://user-images.githubusercontent.com/52024566/164251512-f62d3ff8-18fa-40cc-a902-d20ba9a78c3d.png)

1. 사용자가 검증 범위를 넘어서는 데이터 입력
2. 서버 검증 로직 실패
3. 사용자에게 상품 등록 폼을 다시 보여주고 어떤 값을 잘못 입력했는지 알림

### 상품 등록 검증 Spring

```java
@PostMapping("/add")
public String addItem(@ModelAttribute Item item, RedirectAttributes
redirectAttributes, Model model) {
    //검증 오류 결과를 보관
    Map<String, String> errors = new HashMap<>();
    
    //검증 로직
    if (!StringUtils.hasText(item.getItemName())) {
        errors.put("itemName", "상품 이름은 필수입니다.");
    }
    
    if (item.getPrice() == null || item.getPrice() < 1000 || item.getPrice() > 1000000) {
        errors.put("price", "가격은 1,000 ~ 1,000,000 까지 허용합니다.");
        
    }
    if (item.getQuantity() == null || item.getQuantity() >= 9999) {
        errors.put("quantity", "수량은 최대 9,999 까지 허용합니다.");
    }
    
    //특정 필드가 아닌 복합 룰 검증
    if (item.getPrice() != null && item.getQuantity() != null) {
    int resultPrice = item.getPrice() * item.getQuantity();

        if (resultPrice < 10000) {
            errors.put("globalError", "가격 * 수량의 합은 10,000원 이상이어야 합니다. 현재 값 = " + resultPrice);
        }
    }
    
    //검증에 실패하면 다시 입력 폼으로
    if (!errors.isEmpty()) {
        model.addAttribute("errors", errors);
        return "validation/v1/addForm";
    }
    
    //성공 로직
    Item savedItem = itemRepository.save(item);
    redirectAttributes.addAttribute("itemId", savedItem.getId());
    redirectAttributes.addAttribute("status", true);
    return "redirect:/validation/v1/items/{itemId}";
}
```

### 상품 등록 검증 HTML 

**글로벌 오류 메시지**

```html
<div th:if="${errors?.containsKey('globalError')}">
  <p class="field-error" th:text="${errors['globalError']}">전체 오류 메시지</p>
</div>
```

- 타임리프의 `th:if` 를 사용하면 조건에 만족할 때만 해당 HTML 태그를 출력

> 참고 Safe Navigation Operator
> `errors?.` 은 `errors` 가 `null` 일때 `NullPointerException` 이 발생하는 대신, `null` 을 반환하는 문법
> `th:if` 에서 `null` 은 실패로 처리되므로 오류 메시지가 출력되지 않음
> 참고: https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#expressions-operator-safe-navigation

**필드 오류 처리**

```html
<input type="text" th:classappend="${errors?.containsKey('itemName')} ? 'fielderror' : _" class="form-control">
```

- `classappend`: 해당 필드에 오류가 있으면 `field-error`라는 클래스 정보를 더함
- 값이 없으면 `_`(No-Operation)을 사용하여 아무 일도 하지 않음

### 직접 처리 문제점

- 뷰 템플릿에서 중복된 코드가 많음
- 타입 오류 처리 불가능
  - `Item` 의 `price`, `quantity` 같은 숫자 필드는 타입이 `Integer` 이므로 문자 타입으로 설정하는 것이 불가능
  - 숫자 타입에 문자가 들어오면 오류가 발생하나 이러한 오류는 스프링MVC에서 컨트롤러에 진입하기도 전에 예외가 발생하기 때문에, 컨트롤러가 호출되지도 않고, 400 예외가 발생
- `Item`의 `price`에 문자를 입력하는 것처럼 타입 오류가 발생해도 고객이 입력한 문자를 화면에 남겨야 함
  - 만약 컨트롤러가 호출된다고 가정해도 `Item`의 `price`는 `Integer`이므로 문자를 보관할 수가 없음
  - 결국 문자는 바인딩이 불가능하므로 고객이 입력한 문자가 사라지게 되고, 고객은 본인이 어떤 내용을 입력해서 오류가 발생했는지 이해하기 어려움

## BindingResult

### 필드 오류 - FieldError

```java
if (!StringUtils.hasText(item.getItemName())) {
    bindingResult.addError(new FieldError("item", "itemName", "상품 이름은 필수입니다."));
}
```

**FieldError 생성자 요약**
```java
public FieldError(String objectName, String field, String defaultMessage) {}
```

- `objectName`: `@ModelAttribute` 이름
- `field`: 오류가 발생한 필드 이름
- `defaultMessage`: 오류 기본 메시지

### 글로벌 오류 - ObjectError

```java
bindingResult.addError(new ObjectError("item", "가격 * 수량의 합은 10,000원 이상이어야 합니다. 현재 값 = " + resultPrice));
```

**ObjectError 생성자 요약**
```java
public ObjectError(String objectName, String defaultMessage) {}
```

- `objectName`: `@ModelAttribute` 이름
- `defaultMessage`: 오류 기본 메시지

### 타임리프 스프링 검증 오류 통합 기능

- `#fields`: `#fields`로 `BindingResult`가 제공하는 검증 오류에 접근
- `th:errors`: 해당 필드에 오류가 있는 경우에 태그를 출력
- `th:errorclass`: `th:field`에서 지정한 필드에 오류가 있으면 `class` 정보를 추가
- 검증과 오류 메시지 공식 메뉴얼: https://www.thymeleaf.org/doc/tutorials/3.0/thymeleafspring.html#validation-anderror-messages

**글로벌 오류 처리**

```html
<div th:if="${#fields.hasGlobalErrors()}">
  <p class="field-error" th:each="err : ${#fields.globalErrors()}" th:text="${err}">전체 오류 메시지</p>
</div>
```

**필드 오류 처리**

```html
<input type="text" id="itemName" th:field="*{itemName}"
th:errorclass="field-error" class="form-control" placeholder="이름을
입력하세요">
<div class="field-error" th:errors="*{itemName}">
  상품명 오류
</div>
```

### BindingResult

- 스프링이 제공하는 검증 오류를 보관하는 객체
- BindingResult 가 있으면 `@ModelAttribute` 에 데이터 바인딩 시 오류가 발생해도 컨트롤러 호출
- 예) `@ModelAttribute`에 바인딩 시 타입 오류가 발생하면?
  - `BindingResult` 가 없으면 400 오류가 발생하면서 컨트롤러가 호출되지 않고, 오류 페이지로 이동
  - `BindingResult` 가 있으면 오류 정보( `FieldError` )를 `BindingResult`에 담아서 컨트롤러를 정상 호출
- BindingResult 는 검증할 대상 바로 다음에 와야한다. 순서가 중요하다. 예를 들어서 `@ModelAttribute Item item` , 바로 다음에 `BindingResult`가 와야 함
- `BindingResult`는 `Model`에 자동으로 포함됨

**BindingResult에 검증 오류를 적용하는 3가지 방법**
- `@ModelAttribute`의 객체에 타입 오류 등으로 바인딩이 실패하는 경우 스프링이 `FieldError` 생성해서 `BindingResult` 에 포함
- 개발자가 직접 적용
- Validator 사용

### BindingResult와 Errors
- `org.springframework.validation.Errors`
- `org.springframework.validation.BindingResult`
- `BindingResult`는 인터페이스이고, `Errors` 인터페이스를 상속
- 실제 넘어오는 구현체는 `BeanPropertyBindingResult` 라는 것인데, 둘다 구현하고 있으므로 `BindingResult` 대신에 `Errors`를 사용 가능
- `Errors` 인터페이스는 단순한 오류 저장과 조회 기능을 제공
- `BindingResult`는 여기에 더해서 추가적인 기능들을 제공
- `addError()`도 `BindingResult`가 제공
- 주로 관례상 `BindingResult`를 많이 사용한다.

## FieldError, ObjectError

## 오류 코드와 메시지 처리

## Validator 분리