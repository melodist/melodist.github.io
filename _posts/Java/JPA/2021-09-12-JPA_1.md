---
layout: post
title: 자바 ORM 표준 JPA 프로그래밍 - 기본편 - 1. JPA 소개
tags: [Java, JPA]
permalink: /docs/Java/JPA/JPA_1
date: 2021-09-12 23:33:00
---
# JPA 소개
## SQL 중심적인 개발의 문제점
- 관계형 DB (Oracle, MySQL)에서는 SQL만 사용할 수 있으므로 SQL 의존적인 개발을 할 수 밖에 없다.
- 관계형 DB의 목적과 객체지향 프로그래밍의 목적이 일치하지 않는다.
  그러나, 객체를 저장할 수 있는 가장 현실적인 방안은 관계형 DB이다.

### 객체와 관계형 데이터베이스의 차이

1. 상속

![JPA 소개 - 상속](https://user-images.githubusercontent.com/52024566/132992161-2db24f9c-3106-4d50-bdf1-9b83088d63a3.png)

**DB에서는...**

Album 객체를 저장할 경우 : 객체를 분해하여 artist는 album에 저장, name, price, dtype은 item에 저장
Album 객체를 조회할 경우 : 각 테이블을 조회하는 Join SQL 작성, 각각의 객체 생성... 복잡
**그래서 DB에 저장할 객체에는 상속 관계를 쓰지 않는다.**

**자바에서는...**

Album 객체를 저장할 경우 : `list.add(album);`
Album 객체를 조회할 경우 :`Album album = list.get(albumId);` :arrow_right: `Item item = list.get(albumId);`
부모 타입으로 조회 후 다형성을 활용할 수도 있다.

2. 연관관계

![JPA 소개 - 연관관계](https://user-images.githubusercontent.com/52024566/132992295-e91aa5be-9080-47de-b9e5-efa4ab6a40a2.png)

- 객체는 참조를 사용 : `member.getTeam()`
- 테이블은 외래 키를 사용 : `JOIN ON M.TEAM_ID = T.TEAM_ID`

**객체를 테이블에 맞추어 모델링**

```java
class Member {
	String id;		// MEMBER_ID
	Long teamId;	// TEAM_ID FK
    String username;// USERNAME
}

class Team {
	Long id;		// TEAM_ID PK
	String name;	// NAME
}
```

**객체다운 모델링**

```java
class Member {
	String id;		// MEMBER_ID
	Team team;		// 참조로 연관관계를 맺는다
    String username;// USERNAME
    
    Team getTeam() {
        return team;
    }
}

class Team {
	Long id;		// TEAM_ID PK
	String name;	// NAME
}
```

**객체 모델링 조회**

```sql
SELECT M.*, T.*
  FROM MEMBER M
  JOIN TEAM T ON M.TEAM_ID = T.TEAM_ID
```

```java
public Member find(String memberId) {
    // SQL 실행
    Member member = new Member();
    // 데이터베이스에서 조회한 회원 관련 정보 입력
    Team team = new Team();
    // 데이터베이스에서 조회한 팀 관련 정보 입력
    
    // 회원과 팀 관계 설정
    member.setTeam(team);
    return member;
}
```

이는 굉장히 번거로운 작업이다.

**객체 그래프 탐색**



1. 데이터 타입

2. 데이터 식별 방법

   
