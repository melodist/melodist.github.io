---
layout: post
title: H2 Database
tags: [Java, Spring, WebSquare, UF]
permalink: /docs/OJTPresentation
date: 2021-04-08 10:33:00
---
# OJT 발표 준비

제목: MICROSERVICE ARCHITECTURE 보상 트랜잭션 API

발표는 7분 이내 / 1분에 300자 정도

슬라이드는 몇 장? 30초당 1장 / 14장 이내

각 파트마다 몇 분씩? 2분 30초 / 3분 / 1분 30초

## OJT 발표 개요

1. 주제 선정 배경
2. 구현 내용
3. 결과 및 발전 방향

## OJT 발표 세부 내용

### 1. 주제 선정 배경

From Monolithic Architecture

전통적인 웹 개발 서비스인 Monolithic Architecture는 monolithic이라는 단어 뜻 그대로 모든 애플리케이션이 하나로 되어있는 구조입니다. 전체 애플리케이션이 하나로 되어있어서 보통 동일한 개발 툴을 사용해 개발되며, 배포 및 테스트도 하나의 애플리케이션만 수행하면 되기 때문에 개발 및 환경설정이 간단합니다. 또한 각 컴포넌트들이 함수로 호출 되기 때문에 성능에 제약이 덜하고, 운영 관리가 용이합니다. 이런 장점 때문에 작은 볼륨의 시스템을 개발할 때는 매우 유용하지만 / 시스템이 커지기 시작하고 / 애플리케이션에 여러 컴포넌트들이 더해지면 문제가 발생하기 시작합니다.

**빌드/테스트 시간이 길어집니다.**

작은 수정에도 시스템 전체를 빌드해야 하며 테스트 시간도 길어집니다. 요즘처럼 CI/CD가 강조되는 시점에서는 큰 문제가 될 수 있습니다.

**선택적 확장이 불가능합니다.**

이벤트로 인해 서비스 접속량이 폭증할 경우 프로젝트 전체를 확장해야만 합니다.

**하나의 서비스가 모든 서비스에 영향을 줍니다.**

이벤트 서비스에 트래픽이 몰려 해당 서버가 죽게 된다면 다른 모든 서비스 역시 마비 되는 상황이 오게 됩니다.

To Microservice Architecture

마이크로 서비스 아키텍처(Micro Service Architecture, MSA)란 단일 프로그램을 각 컴포넌트 별로 나누어 작은 서비스의 조합으로 구축하는 방법입니다. 각 컴포넌트는 서비스 형태로 구현되고 API를 이용하여 타 서비스와 통신하게 됩니다. 각 서비스는 독립된 서버로 타 컴포넌트와 의존성이 없기 때문에 독립된 배포를 하게 됩니다. 또한 각 컴포넌트가 독립된 서비스로 개발되어있기 때문에 부분적인 확장이 가능합니다. 온라인 쇼핑몰에서 주문 서비스에 트래픽이 증가한다면 해당 서버만 확장을 해주면 됩니다.

MSA는 복잡한 웹 시스템에 맞춰 개발된 API기반의 서비스 지향적 아키텍처 스타일입니다. MSA가 유행을 하고 있지만 꼭 정답은 아니고, 업무나 비즈니스 특징에 따라 적절한 아키텍처가 선택됩니다. 근래의 아키텍처 모델은 시스템에 대한 설계뿐만 아니라 팀의 구조나 프로젝트 관리 방법까지 달라지기 때문에 프로젝트에 미치는 영향이 매우 크며, 때문에 거시적인 관점에서 고려할 필요가 있습니다.

MSA가 필요하다고 해도 꼭 시작을 MSA로 해야 하는 것은 아닙니다. MSA가 서비스의 재사용 성, 유연한 아키텍처구조, 대용량 웹 서비스에 적합한 구조 등 많은 장점을 가지고 있지만 개개인의 높은 숙련도가 필요한 편입니다. MSA를 구축한 많은 기업들이 시작은 모노리틱 시스템으로 시작하여 팀원들의 숙련도를 높이고 피드백을 통해 시스템을 발전 시키는 과정에서 MSA로 전환한 사례들도 있습니다. 프로젝트의 목적이나 팀의 상황에 맞는 유연한 선택이 필요합니다.

Problems

트랜잭션의

트랜잭션 - 데이터 일관성을 유지하는 것이 중요

분산 트랜잭션 - 동일한 DB를 사용해야 함. 이는 다양한 플랫폼으로 개발할 수 있다는 MSA의 장점을 퇴색시킴.
또한 트랜잭션이 걸린 모든 서비스들이 동기 IPC를 유지해야 하기 때문에 MSA에서의 가용성이 떨어짐

보상 트랜잭션을 요청하기 위하여 필요한 다양한 parameter와 클래스들

이를 API(Application Programming Interface)로 구현하여 개발자가 비즈니스 로직 구현에만 집중할 수 있게 보상 트랜잭션 요청을 간단한 코드로 사용할 수 있도록 하는 것이 목표

### 2. 구현 내용

시연 시나리오 설명

| 성공                                                         | 실패                                                         |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| 1. 주문 생성<br />2. 재고 차감<br />3. 결제 성공<br />4. 주문 성공 | 1. 주문 생성<br />2. 재고 차감<br />3. 결제 실패<br />4. 보상 트랜잭션 요청<br />5. 재고 복구<br />6. 주문 실패 |

주문, 물류, 결제 아이콘

보상 트랜잭션 동작 과정

1. 보상 트랜잭션 기준 정보를 등록

2. 서비스가 보상 트랜잭션 요청. 이 때 사용하는 parameter는 1에서 등록한 ID와 보상 트랜잭션에 필요한 parameter

3. 보상 트랜잭션 API가 ID를 보상 트랜잭션 기준 정보 DB에서 조회하여 보상 트랜잭션 서비스의 URL, 동기/비동기 여부 확인

4. 동기/비동기 보상 트랜잭션 요청 서비스 호출
5. 보상 트랜잭션 이력 기록
6. 보상 트랜잭션 요청
7. 보상 트랜잭션 이록 갱신

구현 내용은 GameBar로 촬영

SpringBoot WebSquare Bootstrap

촬영한 영상 부분 확대로 강조

### 3. 결과 및 발전 방향

기대 효과

MSA에서는 서비스 별로 팀을 나누고 서비스 기획에서부터 설계 개발 운영이 팀 내에서 이루어지기 때문에 다른 팀에 대한 의존성이 사라지게 됩니다. 역할별 요청과 피드백이 빨라지고, 때문에 유연하고 지속적인 운영과 개발이 함께하게 됩니다.

## OJT 발표 스크립트

안녕하세요, DS사업1담당 Dev파트 박준화입니다. 제가 진행한 OJT 과제 주제는 Microservice Architecture 보상 트랜잭션 API입니다. 먼저 발표 순서를 말씀드리겠습니다. 발표는 서론, 개발, 시연, 그리고 결론의 4부분으로 구성되어 있습니다. 그럼 먼저, 제가 OJT 과제 주제를 선정한 배경과 OJT 과제의 목표에 대하여 말씀드리겠습니다.

### 1. 주제 선정 배경

#### MicroService Architecture

기존에 널리 사용되었던 Monolithic Architecture의 단점을 극복하기 위하여 흔히 MSA라고 부르는 MicroService Architecture가 제시되었습니다.  MSA란 하나의 애플리케이션을 기능별로 나누어진 작은 서비스의 조합으로 구축하는 방법입니다.  각 서비스는 독립된 서버로 타 서비스에 대한 의존성이 없기 때문에 독립적인 배포가 가능하므로 기능의 수정과 확장이 쉽습니다.  이러한 특징 때문에 MSA는 시장의 변화에 신속하게 대처할 수 있다는 장점을 갖고 있습니다.  그래서 아마존, 넷플릭스를 비롯한 유수의 IT 기업이 MSA를 도입하고 있습니다. 제가 참여한 CJ ENM 커머스 부문 영업시스템 리뉴얼 구축 프로젝트에서도 MSA를 도입하였습니다.

#### MSA의 문제점

하지만 MSA가 장점만을 갖고 있는 것은 아닙니다. MSA의 문제점을 설명하기 위하여 먼저 Monolithic Architecutre의 예를 들어보겠습니다. 고객이 CJmall에서 상품을 주문할 경우 / 주문, 재고 차감, 결제의 모든 과정이 연속적으로 일어나야 하는데 / 이러한 일련의 과정들을 묶어서 Transaction이라고 합니다. / Transaction이 완료되면 Commit 연산으로 데이터베이스에 주문 결과를 기록합니다. 하지만 Transaction 도중에 오류가 발생했을 경우 / Rollback 연산으로 Transaction의 모든 과정을 취소해야 합니다. Monolithic Architecture에서는 모든 서비스가 한 곳에 있기 때문에 Rollback 연산을 정상적으로 수행할 수 있습니다.

MSA의 경우는 어떨까요? MSA를 도입할 경우 / 각 기능은 독립된 서버로 나누어져 각자의 데이터베이스를 가지게 됩니다. 따라서, 주문 서비스와 물류 서비스는 각자의 작업을 진행하고 각자의 Database에 그 결과를 Commit합니다. 그런데, 결제 과정 중 오류가 발생했을 경우 결제 서비스는 자신의 Database를 Rollback합니다. 하지만 이미 Commit이 끝난 물류 서비스는 / 어떻게 해야 할까요?

물류 서비스의 commit을 취소하기 위해서는 commit 결과를 보정하는 보상 트랜잭션이 수행되어야 합니다. 하지만 개발자가 보상 트랜잭션을 요청하기 위해서는 다양한 파라미터를 입력해야 합니다. 이를 각각의 서비스에서 코드로 입력하는 것은 비효율적입니다.

#### MSA 보상 트랜잭션 API의 필요성

보상 트랜잭션 요청 기능을 API로 구현한다면 각 서비스의 개발자는 Business Logic 개발에만 집중할 수 있어서 /  개발 생산성을 높일 수 있습니다. 그래서 본 과제에서는 MSA 보상 트랜잭션 API를 개발하였습니다.

### 2. 개발

다음으로 OJT 과제의 개발 과정에 대하여 설명 드리겠습니다.

#### MSA 보상 트랜잭션 API 개발 과정

보상 트랜잭션 API의 개발 과정은 실제 프로그램이 개발되는 과정대로 / 처음부터 진행하여 업무 프로세스에 대한 이해도 뿐만 아니라 프로그램 설계에 대한 이해도까지 동시에 높일 수 있었습니다.

#### MSA 보상 트랜잭션 API 개발 상세

보상 트랜잭션 API의 pseudocode로 API의 실행 과정을 상세하게 설명 드리겠습니다. / Service1이 자신의 Transaction을 마치고 Service2를 호출합니다. Service2가 자신의 Transaction을 진행하는 도중 / 예외가 발생했을 경우 Service1에 대한 보상 트랜잭션 ID와 파라미터를 가지고 / API에게 보상 트랜잭션 호출을 요청합니다. /  이 때, ID는 사전에 기준 정보 테이블에 기록한 ID를 이용합니다. /

보상 트랜잭션 API는 parameter로 입력받은 ID를 가지고 보상 트랜잭션의 기준 정보를 조회합니다. / 그리고 해당 보상 트랜잭션의 동기/비동기 여부에 따라 각각 다른 요청 메소드를 호출합니다. / 동기 방식으로 요청할 경우 Service2는 API가 결과를 반환하기까지 대기하고 / 비동기 방식으로 요청할 경우 Service2는 결과를 기다리지 않고 자신의 나머지 동작을 수행합니다.

보상 트랜잭션 요청 메소드는 / 동기와 비동기 모두 같은 HTTP 요청 메소드를 호출하지만 비동기 메소드는 Spring에서 지원하는 / @Async Annotation을 사용하여 비동기 방식으로 동작하는 것이 차이점입니다. HTTP 요청 메소드는 입력받은 parameter로 / HTTP 요청을 보상 트랜잭션 서비스에 보내고 받은 응답에 따라 / 보상 트랜잭션 이력을 기록합니다.

### 3. 시연

다음으로 제가 구현한 MSA 보상 트랜잭션 API의 실행 결과를 보여드리겠습니다. 

#### 시연 시나리오 설명

시연하기 이전에 시나리오에 대하여 간단히 설명 드리겠습니다. 실제 구매 프로세스와는 차이가 있지만 API의 시연을 위해 단순한 시나리오를 준비했습니다. / 고객이 CJmall을 통하여 상품을 주문했을 때 / 서비스 3개가 / 순서대로 호출되고 / 그 과정에서 결제에 실패하여 결제 서비스는 / 보상 트랜잭션 API를 호출합니다. API는 보상 트랜잭션 서비스를 호출하고 / 보상 트랜잭션 서비스는 차감된 재고를 복구합니다. / 최종적으로 주문은 취소 상태로 변경됩니다.

#### 시연에 사용한 Tech Stack

보상 트랜잭션 API를 포함한 시연 데모는 다음과 같은 기술 스택을 사용하여 개발하였습니다. / 업무에 빠르게 적응할 수 있도록 프로젝트에서 사용하는 기술 스택을 OJT 과제 개발에 최대한 활용하였습니다.

#### 시연

<<<<<<< HEAD
시연 데모 화면입니다. 먼저, 기준 정보 화면을 통하여 보상 트랜잭션 기준 정보를 조회, 등록 및 수정할 수 있습니다. 이제 보상 트랜잭션 API가 실행되는 과정을 보여드리겠습니다.  주문, 물류, 결제로 이어지는 프로세스가 자동으로 동작하는 것이 맞지만 각 서비스의 상태를 보여드리기 위하여 서비스를 분리하였습니다. 고객이 주문을 할 경우 주문 서비스에서는 주문을 PENDING 상태로 생성합니다. 주문이 생성되면 물류 서비스에서는 재고를 차감합니다. 100이었던 재고가 99로 감소한 것을 확인할 수 있습니다. 결제 서비스에서는 결제가 실패하였을 경우 보상 트랜잭션 API를 호출하고 보상 트랜잭션 API는 물류 보상 트랜잭션 서비스를 호출하여 재고를 복구합니다. 99였던 재고가 100으로 복구된 것을 확인할 수 있습니다. 보상 트랜잭션 서비스가 실행된 이력은 별도의 화면으로 조회할 수 있습니다. 보상 트랜잭션 서비스가 성공한 것을 확인할 수 있습니다. 그리고 최종적으로 주문 상태가 CANCELLED 상태로 변경되었습니다.
=======
시연 데모 화면입니다. 먼저, 기준 정보 화면을 통하여 보상 트랜잭션 기준 정보를 조회, 등록 및 수정할 수 있습니다. 이제 보상 트랜잭션 API가 실행되는 과정을 보여드리겠습니다. 주문, 물류, 결제로 이어지는 프로세스가 자동으로 동작하는 것이 맞지만 각 서비스의 상태를 보여드리기 위하여 서비스를 분리하였습니다. 고객이 주문을 할 경우 주문 서비스에서는 주문을 PENDING 상태로 생성합니다.  주문이 생성되면 물류 서비스에서는 재고를 차감합니다. 100이었던 재고가 99로 감소한 것을 확인할 수 있습니다. 결제 서비스에서는 결제가 실패하였을 경우 보상 트랜잭션 API를 호출하고 보상 트랜잭션 API는 물류 보상 트랜잭션 서비스를 호출하여 재고를 복구합니다. 99였던 재고가 100으로 복구된 것을 확인할 수 있습니다. 보상 트랜잭션 서비스가 실행된 이력은 별도의 화면으로 조회할 수 있습니다. 보상 트랜잭션 서비스가 성공한 것을 확인할 수 있습니다. 그리고 최종적으로 주문 상태가 CANCELLED 상태로 변경되었습니다.
>>>>>>> 66271b9c33cb73b9e9f3e7223f4d41c5710eba7a

### 4. 결론

#### 향후 계획

본 과제에서 개발한 API는 서비스에서 요청하는 보상 트랜잭션만을 실시간으로 처리할 수 있습니다. 그러나 API에서 요청한 보상 트랜잭션도 실패할 가능성이 있기 때문에 이에 대비하여 실패한 보상 트랜잭션을 재시도하는 배치 프로그램 또한 필요합니다. 향후에는 이러한 배치 프로그램을 개발하여 보상 트랜잭션의 실행을 보장할 예정입니다. 또한, CJ ENM 커머스 부문 영업시스템 리뉴얼 구축 프로젝트에 도입이 가능하도록 API의 기능을 고도화 할 예정입니다.

#### 기대 효과

본 과제에서 개발한 API를 통하여 데이터 Transaction의 일관성을 유지하기 어렵다는 MSA의 고질적인 문제점을 해결할 수 있습니다. 또한, MSA에 꼭 필요한 보상 트랜잭션 요청 프로그램을 API로 구현하여 개발 생산성을 향상 시킬 수 있습니다. 이러한 장점을 바탕으로 본 과제에서 개발한 API는 지속적이고 신속한 서비스 혁신을 통한 Time-To-Market 단축을 가능케 할 것입니다.

#### OJT 소감과 포부

OJT 과제를 시작할 때에는 모르는 것이 많았기 때문에 어떻게 해야 할 지 막막했습니다. 하지만 OJT 과제를 작은 단계로 나누고 그 단계를 하나씩 성취하는 과정에서 자신감을 얻을 수 있었습니다. 그리고 제가 참여한 프로젝트와 직접적인 연관이 있는 과제를 수행하면서 직무에 대한 이해를 쌓을 수 있었을 뿐만 아니라 소프트웨어가 개발되는 과정을 따라 OJT 과제를 진행하면서 개발 프로세스에 대한 이해도 쌓을 수 있었습니다. 이러한 경험을 바탕으로 적극적으로 문제를 해결하여 좋은 가치를 공유하는 개발자로 성장하고 싶습니다.

#### 마무리

끝으로 OJT 과제 수행하는 것을 도와주신 멘토 김철영님을 비롯한 많은 분들께 감사드립니다. 이상으로 OJT 과제 발표를 마치겠습니다. 들어주셔서 감사합니다.