---
layout: post
title: H2 Database
tags: [Java, Spring, WebSquare, UF]
permalink: /docs/OJTPresentation
date: 2021-04-08 10:33:00
---
# OJT 발표 준비

제목: MICROSERVICE ARCHITECTURE 보상 트랜잭션 API

발표는 7분 이내

슬라이드는 몇 장? 30초당 1장 / 14장 이내

각 파트마다 몇 분씩? 2분 30초 / 3분 / 1분 30초

## OJT 발표 개요

1. 주제 선정 배경
2. 구현 내용
3. 결과 및 발전 방향

## OJT 발표 세부 내용

### 1. 주제 선정 배경

From Monolithic Architecture

전통적인 웹 개발 서비스인 Monolithic Architecture는 monolithic이라는 단어 뜻 그대로 모든 애플리케이션이 하나로 되어있는 구조입니다. 전체 애플리케이션이 하나로 되어있어서 보통 동일한 개발 툴을 사용해 개발되며, 배포 및 테스트도 하나의 애플리케이션만 수행하면 되기 때문에 개발 및 환경설정이 간단합니다. 또한 각 컴포넌트들이 함수로 호출 되기 때문에 성능에 제약이 덜하고, 운영 관리가 용이합니다. 이런 장점 때문에 작은 볼륨의 시스템을 개발할 때는 매우 유용하지만 시스템이 커지기 시작하고 여러 컴포넌트들이 더해지면 문제가 발생하기 시작합니다.

**빌드/테스트 시간이 길어집니다.**

작은 수정에도 시스템 전체를 빌드해야 하며, 테스트 시간도 길어집니다. 요즘처럼 CI/CD가 강조되는 시점에서는 큰 문제가 될 수 있습니다.

**선택적 확장이 불가능합니다.**

이벤트로 인해 서비스 접속 량이 폭증할 경우 프로젝트 전체를 확장해야만 합니다.

**하나의 서비스가 모든 서비스에 영향을 줍니다.**

이벤트 서비스에 트래픽이 몰려 해당 서버가 죽게 된다면 다른 모든 서비스 역시 마비 되는 상황이 오게 됩니다.

To Microservice Architecture

마이크로 서비스 아키텍처(Micro Service Architecture, MSA)란 단일 프로그램을 각 컴포넌트 별로 나누어 작은 서비스의 조합으로 구축하는 방법입니다. 각 컴포넌트는 서비스 형태로 구현되고 API를 이용하여 타 서비스와 통신하게 됩니다. 각 서비스는 독립된 서버로 타 컴포넌트와 의존성이 없기 때문에 독립된 배포를 하게 됩니다. 또한 각 컴포넌트가 독립된 서비스로 개발되어있기 때문에 부분적인 확장이 가능합니다. 온라인 쇼핑몰에서 주문 서비스에 트래픽이 증가한다면 해당 서버만 확장을 해주면 됩니다.

MSA는 복잡한 웹 시스템에 맞춰 개발된 API기반의 서비스 지향적 아키텍처 스타일입니다. MSA가 유행을 하고 있지만 꼭 정답은 아니고, 업무나 비즈니스 특징에 따라 적절한 아키텍처가 선택됩니다. 근래의 아키텍처 모델은 시스템에 대한 설계뿐만 아니라 팀의 구조나 프로젝트 관리 방법까지 달라지기 때문에 프로젝트에 미치는 영향이 매우 크며, 때문에 거시적인 관점에서 고려할 필요가 있습니다.

MSA가 필요하다고 해도 꼭 시작을 MSA로 해야 하는 것은 아닙니다. MSA가 서비스의 재사용 성, 유연한 아키텍처구조, 대용량 웹 서비스에 적합한 구조 등 많은 장점을 가지고 있지만 개개인의 높은 숙련도가 필요한 편입니다. MSA를 구축한 많은 기업들이 시작은 모노리틱 시스템으로 시작하여 팀원들의 숙련도를 높이고 피드백을 통해 시스템을 발전 시키는 과정에서 MSA로 전환한 사례들도 있습니다. 프로젝트의 목적이나 팀의 상황에 맞는 유연한 선택이 필요합니다.

Problems

트랜잭션의

트랜잭션 - 데이터 일관성을 유지하는 것이 중요

분산 트랜잭션 - 동일한 DB를 사용해야 함. 이는 다양한 플랫폼으로 개발할 수 있다는 MSA의 장점을 퇴색시킴.
또한 트랜잭션이 걸린 모든 서비스들이 동기 IPC를 유지해야 하기 때문에 MSA에서의 가용성이 떨어짐

보상 트랜잭션을 요청하기 위하여 필요한 다양한 parameter와 클래스들

이를 API(Application Programming Interface)로 구현하여 개발자가 비즈니스 로직 구현에만 집중할 수 있게 보상 트랜잭션 요청을 간단한 코드로 사용할 수 있도록 하는 것이 목표

### 2. 구현 내용

시연 시나리오 설명

| 성공                                                         | 실패                                                         |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| 1. 주문 생성<br />2. 재고 차감<br />3. 결제 성공<br />4. 주문 성공 | 1. 주문 생성<br />2. 재고 차감<br />3. 결제 실패<br />4. 보상 트랜잭션 요청<br />5. 재고 복구<br />6. 주문 실패 |

주문, 물류, 결제 아이콘

보상 트랜잭션 동작 과정

1. 보상 트랜잭션 기준 정보를 등록

2. 서비스가 보상 트랜잭션 요청. 이 때 사용하는 parameter는 1에서 등록한 ID와 보상 트랜잭션에 필요한 parameter

3. 보상 트랜잭션 API가 ID를 보상 트랜잭션 기준 정보 DB에서 조회하여 보상 트랜잭션 서비스의 URL, 동기/비동기 여부 확인

4. 동기/비동기 보상 트랜잭션 요청 서비스 호출
5. 보상 트랜잭션 이력 기록
6. 보상 트랜잭션 요청
7. 보상 트랜잭션 이록 갱신

구현 내용은 GameBar로 촬영

SpringBoot WebSquare Bootstrap

촬영한 영상 부분 확대로 강조

### 3. 결과 및 발전 방향

기대 효과

MSA에서는 서비스 별로 팀을 나누고 서비스 기획에서부터 설계 개발 운영이 팀 내에서 이루어지기 때문에 다른 팀에 대한 의존성이 사라지게 됩니다. 역할별 요청과 피드백이 빨라지고, 때문에 유연하고 지속적인 운영과 개발이 함께하게 됩니다.

## OJT 발표 스크립트

### 1. 주제 선정 배경

From Monolithic Architecture

전통적인 웹 개발 서비스인 Monolithic Architecture는 monolithic이라는 단어 뜻 그대로 모든 애플리케이션이 하나로 되어있는 구조입니다. 전체 애플리케이션이 하나로 되어있어서 보통 동일한 개발 툴을 사용해 개발되며, 배포 및 테스트도 하나의 애플리케이션만 수행하면 되기 때문에 개발 및 환경설정이 간단합니다. 또한 각 컴포넌트들이 함수로 호출 되기 때문에 성능에 제약이 덜하고, 운영 관리가 용이합니다. 이런 장점 때문에 작은 볼륨의 시스템을 개발할 때는 매우 유용하지만 시스템이 커지기 시작하고 여러 컴포넌트들이 더해지면 문제가 발생하기 시작합니다.

**빌드/테스트 시간이 길어집니다.**

작은 수정에도 시스템 전체를 빌드해야 하며, 테스트 시간도 길어집니다. 요즘처럼 CI/CD가 강조되는 시점에서는 큰 문제가 될 수 있습니다.

**선택적 확장이 불가능합니다.**

이벤트로 인해 서비스 접속 량이 폭증할 경우 프로젝트 전체를 확장해야만 합니다.

**하나의 서비스가 모든 서비스에 영향을 줍니다.**

이벤트 서비스에 트래픽이 몰려 해당 서버가 죽게 된다면 다른 모든 서비스 역시 마비 되는 상황이 오게 됩니다.

### 2. 구현 내용

제가 구현한 MSA 보상 트랜잭션 API의 실행 과정을 간단하게 설명드리기 위하여 다음과 같이 고객이 CJmall을 통하여 주문을 하는 상황을 가정하여 보겠습니다. 고객이 상품을 주문하면 주문 서비스에서는 대기 상태의 주문을 생성하고 주문 서비스는 물류 서비스를 호출합니다. 물류 서비스는 주문한 상품의 재고를 차감하고 결제 서비스를 호출합니다. 결제가 성공하면 결제 서비스는 그 결과를 주문 서비스에 전달하고 최종적으로 주문이 승인 상태로 변경됩니다. 이렇게 고객이 주문을 요청하고 주문이 승인되기까지의 과정은 하나의 트랜잭션으로 관리됩니다.

하지만, 결제 서비스에서 문제가 발생하여 결제가 실패할 경우 물류 서비스는 차감된 재고를 원상태로 복구해야 합니다. 기존의 Monolithic Service에서는 모든 서비스가 하나의 DB를 사용했기 때문에 단순히 트랜잭션을 rollback 하는 것으로 문제를 해결할 수 있습니다. 하지만 MSA에서는 각 서비스가 각자의 DB를 사용하기 때문에 

### 3. 결과 및 발전 방향