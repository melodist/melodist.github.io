---
layout: post
title: H2 Database
tags: [Java, Spring, WebSquare, UF]
permalink: /docs/OJTPresentation
date: 2021-04-08 10:33:00
---
# OJT 발표 준비

제목: MICROSERVICE ARCHITECTURE 보상 트랜잭션 API

발표는 7분 이내 / 1분에 300자 정도

슬라이드는 몇 장? 30초당 1장 / 14장 이내

각 파트마다 몇 분씩? 2분 30초 / 3분 / 1분 30초

## OJT 발표 개요

1. 주제 선정 배경
2. 구현 내용
3. 결과 및 발전 방향

## OJT 발표 세부 내용

### 1. 주제 선정 배경

From Monolithic Architecture

전통적인 웹 개발 서비스인 Monolithic Architecture는 monolithic이라는 단어 뜻 그대로 모든 애플리케이션이 하나로 되어있는 구조입니다. 전체 애플리케이션이 하나로 되어있어서 보통 동일한 개발 툴을 사용해 개발되며, 배포 및 테스트도 하나의 애플리케이션만 수행하면 되기 때문에 개발 및 환경설정이 간단합니다. 또한 각 컴포넌트들이 함수로 호출 되기 때문에 성능에 제약이 덜하고, 운영 관리가 용이합니다. 이런 장점 때문에 작은 볼륨의 시스템을 개발할 때는 매우 유용하지만 / 시스템이 커지기 시작하고 / 애플리케이션에 여러 컴포넌트들이 더해지면 문제가 발생하기 시작합니다.

**빌드/테스트 시간이 길어집니다.**

작은 수정에도 시스템 전체를 빌드해야 하며 테스트 시간도 길어집니다. 요즘처럼 CI/CD가 강조되는 시점에서는 큰 문제가 될 수 있습니다.

**선택적 확장이 불가능합니다.**

이벤트로 인해 서비스 접속량이 폭증할 경우 프로젝트 전체를 확장해야만 합니다.

**하나의 서비스가 모든 서비스에 영향을 줍니다.**

이벤트 서비스에 트래픽이 몰려 해당 서버가 죽게 된다면 다른 모든 서비스 역시 마비 되는 상황이 오게 됩니다.

To Microservice Architecture

마이크로 서비스 아키텍처(Micro Service Architecture, MSA)란 단일 프로그램을 각 컴포넌트 별로 나누어 작은 서비스의 조합으로 구축하는 방법입니다. 각 컴포넌트는 서비스 형태로 구현되고 API를 이용하여 타 서비스와 통신하게 됩니다. 각 서비스는 독립된 서버로 타 컴포넌트와 의존성이 없기 때문에 독립된 배포를 하게 됩니다. 또한 각 컴포넌트가 독립된 서비스로 개발되어있기 때문에 부분적인 확장이 가능합니다. 온라인 쇼핑몰에서 주문 서비스에 트래픽이 증가한다면 해당 서버만 확장을 해주면 됩니다.

MSA는 복잡한 웹 시스템에 맞춰 개발된 API기반의 서비스 지향적 아키텍처 스타일입니다. MSA가 유행을 하고 있지만 꼭 정답은 아니고, 업무나 비즈니스 특징에 따라 적절한 아키텍처가 선택됩니다. 근래의 아키텍처 모델은 시스템에 대한 설계뿐만 아니라 팀의 구조나 프로젝트 관리 방법까지 달라지기 때문에 프로젝트에 미치는 영향이 매우 크며, 때문에 거시적인 관점에서 고려할 필요가 있습니다.

MSA가 필요하다고 해도 꼭 시작을 MSA로 해야 하는 것은 아닙니다. MSA가 서비스의 재사용 성, 유연한 아키텍처구조, 대용량 웹 서비스에 적합한 구조 등 많은 장점을 가지고 있지만 개개인의 높은 숙련도가 필요한 편입니다. MSA를 구축한 많은 기업들이 시작은 모노리틱 시스템으로 시작하여 팀원들의 숙련도를 높이고 피드백을 통해 시스템을 발전 시키는 과정에서 MSA로 전환한 사례들도 있습니다. 프로젝트의 목적이나 팀의 상황에 맞는 유연한 선택이 필요합니다.

Problems

트랜잭션의

트랜잭션 - 데이터 일관성을 유지하는 것이 중요

분산 트랜잭션 - 동일한 DB를 사용해야 함. 이는 다양한 플랫폼으로 개발할 수 있다는 MSA의 장점을 퇴색시킴.
또한 트랜잭션이 걸린 모든 서비스들이 동기 IPC를 유지해야 하기 때문에 MSA에서의 가용성이 떨어짐

보상 트랜잭션을 요청하기 위하여 필요한 다양한 parameter와 클래스들

이를 API(Application Programming Interface)로 구현하여 개발자가 비즈니스 로직 구현에만 집중할 수 있게 보상 트랜잭션 요청을 간단한 코드로 사용할 수 있도록 하는 것이 목표

### 2. 구현 내용

시연 시나리오 설명

| 성공                                                         | 실패                                                         |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| 1. 주문 생성<br />2. 재고 차감<br />3. 결제 성공<br />4. 주문 성공 | 1. 주문 생성<br />2. 재고 차감<br />3. 결제 실패<br />4. 보상 트랜잭션 요청<br />5. 재고 복구<br />6. 주문 실패 |

주문, 물류, 결제 아이콘

보상 트랜잭션 동작 과정

1. 보상 트랜잭션 기준 정보를 등록

2. 서비스가 보상 트랜잭션 요청. 이 때 사용하는 parameter는 1에서 등록한 ID와 보상 트랜잭션에 필요한 parameter

3. 보상 트랜잭션 API가 ID를 보상 트랜잭션 기준 정보 DB에서 조회하여 보상 트랜잭션 서비스의 URL, 동기/비동기 여부 확인

4. 동기/비동기 보상 트랜잭션 요청 서비스 호출
5. 보상 트랜잭션 이력 기록
6. 보상 트랜잭션 요청
7. 보상 트랜잭션 이록 갱신

구현 내용은 GameBar로 촬영

SpringBoot WebSquare Bootstrap

촬영한 영상 부분 확대로 강조

### 3. 결과 및 발전 방향

기대 효과

MSA에서는 서비스 별로 팀을 나누고 서비스 기획에서부터 설계 개발 운영이 팀 내에서 이루어지기 때문에 다른 팀에 대한 의존성이 사라지게 됩니다. 역할별 요청과 피드백이 빨라지고, 때문에 유연하고 지속적인 운영과 개발이 함께하게 됩니다.

## OJT 발표 스크립트

안녕하세요, DS사업1담당 Dev파트 박준화입니다. 제가 진행한 OJT 과제 주제는 Microservice Architecture 보상 트랜잭션 API입니다. 본격적인 발표를 시작하기에 앞서 발표 순서를 말씀드리겠습니다. 발표는 주제 선정 배경 및 목표, 구현 내용, 시연, 결론의 4가지 부분으로 구성되어 있습니다.  그럼 먼저, 제가 OJT 과제 주제를 선정한 배경과 OJT 과제의 목표에 대하여 말씀드리겠습니다.

### 1. 주제 선정 배경

#### Monolithic Architecture

지금도 널리 사용되고 있는 개발 방식인 Monolithic Architecture는 / monolithic이라는 단어 뜻 그대로 / 애플리케이션의 모든 구성 요소가 하나로 되어있는 구조입니다. Monolithic Architecture는 전체 애플리케이션이 하나로 되어있기 때문에 / 동일한 개발 툴을 사용하여 개발됩니다. 따라서, 개발 및 환경설정이 간단합니다. 또한 각 구성 요소들이 함수로 호출 되기 때문에 성능의 제약을 덜 받고, 운영 관리가 용이하다는 장점도 있습니다. 이런 장점 때문에  Monolithic Architecture는 작은 볼륨의 시스템을 개발할 때는 유용하지만 / 시스템이 커지기 시작하고 / 애플리케이션에 여러 기능이 더해지면 문제점이 나타납니다.

먼저, **빌드/테스트 시간이 길어집니다.**

작은 수정에도 시스템 전체를 빌드해야 하며, 테스트 시간도 길어집니다. 요즘처럼 CI/CD가 강조되는 시점에서는 큰 문제가 될 수 있습니다.

그리고, **선택적 확장이 불가능합니다.**

이벤트로 인해 서비스 접속량이 폭증할 경우 프로젝트 전체를 확장해야만 합니다.

마지막으로 **하나의 서비스가 모든 서비스에 영향을 줍니다.**

이벤트 서비스에 트래픽이 몰려 해당 서버가 죽게 된다면 다른 모든 서비스 역시 마비 되는 상황이 오게 됩니다.

#### Microservice Architecture

이러한 Monolithic Architecture의 단점을 극복하기 위하여 흔히 MSA라고 부르는 MicroService Architecture가 제시되었습니다. MSA란 하나의 애플리케이션을 기능별로 나누어진 작은 서비스의 조합으로 구축하는 방법입니다. 각 서비스는 독립된 서버로 타 서비스에 대한 의존성이 없기 때문에 독립적인 배포가 가능하므로 기능의 수정과 확장이 쉽습니다.  이러한 특징 때문에 MSA는 시장의 변화에 신속하게 대처할 수 있다는 장점을 갖고 있습니다. 그래서 아마존, 넷플릭스를 비롯한 유수의 IT 기업이 MSA를 도입하고 있습니다.

#### MSA의 문제점

하지만 MSA가 장점만을 갖고 있는 것은 아닙니다. MSA의 문제점을 설명하기 위하여 간단한 예를 들어보겠습니다. 고객이 CJmall에서 상품을 주문할 경우 주문 서비스가 주문을 생성하고 / 물류 서비스는 재고를 차감하고 / 결제 서비스는 결제를 진행합니다. 모든 과정은 나눠질 수 없고 연속적으로 일어나야 하는데 이러한 일련의 과정들을 묶어서 Transaction이라고 합니다. Transaction이 완료되면 Commit 연산으로 데이터베이스에 주문 결과를 기록합니다.

하지만 Transaction 도중에 오류가 발생했을 경우, 여기서는 결제 과정 중 오류가 발생한 상황을 가정하여 보겠습니다. 이러한 상황에서는 Rollback 연산으로 Transaction의 모든 과정을 취소해야 합니다. Monolithic Architecture에서는 모든 서비스가 하나의 서버에 있기 때문에 Rollback 연산을 아무런 문제없이 수행할 수 있습니다.

MSA의 경우는 어떨까요? MSA를 도입할 경우 각 기능은 독립된 서버로 나누어져 각자의 데이터베이스를 가지게 됩니다. 고객이 CJmall에서 상품을 주문할 경우 주문 서비스는 주문 서비스를 생성하고 그 결과를 자신의 데이터베이스에 Commit합니다.  물류 서비스도 마찬가지로 연산 결과를 각자의 데이터베이스에 Commit하게 되는데 / 결제 과정 중 오류가 발생했을 경우 결제 서비스는 자신의 Database를 Rollback합니다. / 하지만 이미 Commit이 끝난 물류 서비스는 / 어떻게 해야 할까요?

물류 서비스의 Transaction의 commit을 취소하기 위하여 보상 트랜잭션이 수행되어야 합니다. 하지만 보상 트랜잭션을 요청하기 위해서 개발자는 다양한 파라미터를 입력해야 합니다. 이를 각각의 서비스에서 코드로 입력하는 것은 비효율적입니다. 

보상 트랜잭션 요청 기능을 API로 구현한다면 보상 트랜잭션을 요청할 때 각 서비스의 개발자가 Business Logic 개발에 집중할 수 있어서 개발 생산성을 높일 수 있습니다. 그래서 본 과제에서는 보상 트랜잭션을 요청하는 기능을 API로 구현하고자 합니다. 

### 2. 구현 내용

다음으로 보상 트랜잭션 API가 동작하는 과정을 설명 드리겠습니다. 먼저 보상 트랜잭션 API를 사용하기 이전에 / 보상 트랜잭션 요청에 필요한 파라미터를 테이블에 저장해야 합니다. / 테이블에는 다음과 같은 내용이 들어갑니다. 따라서, 개발자가 서비스에서 보상 트랜잭션을 요청할 때는 테이블에 입력한 ID와 데이터베이스 연산에 필요한 parameter만 입력하면 됩니다.

서비스에서 보상 트랜잭션 API를 호출하면 / API는 입력받은 ID로 앞서 저장한 보상 트랜잭션 기준 정보를 조회합니다. / API가 조회한 정보를 가지고 보상 트랜잭션 서비스를 요청하면 / 보상 트랜잭션을 수행하는 서비스는 보상 트랜잭션을 수행하고 / 그 결과를 API에 반환합니다. 그리고, API는 / 보상 트랜잭션 수행 결과를 보상 트랜잭션 이력 테이블에 저장합니다. / 보상 트랜잭션이 실행된 이력은 별도의 화면을 통하여 조회할 수 있습니다.

### 3. 시연

다음으로 제가 구현한 MSA 보상 트랜잭션 API의 실행 결과를 보여드리겠습니다. 시연하기 이전에, 시연 시나리오에 대하여 간단히 설명 드리겠습니다. 고객이 CJmall을 통하여 상품을 주문하면 / 주문 서비스에서는 대기 상태의 주문을 생성하고 주문 서비스는 물류 서비스를 호출합니다. / 물류 서비스는 주문한 상품의 재고를 차감하고 결제 서비스를 호출합니다. / 결제가 성공하면 결제 서비스는 그 결과를 주문 서비스에 전달하고 최종적으로 주문이 승인 상태로 변경되지만, / 결제가 실패할 경우 결제 서비스는 보상 트랜잭션 API를 호출합니다. API는 보상 트랜잭션 서비스를 호출하고 보상 트랜잭션 서비스는 차감된 재고를 복구합니다. 최종적으로 주문은 취소 상태로 변경됩니다.

보상 트랜잭션 API를 포함한 시연 시나리오는 다음과 같은 기술 스택을 사용하여 개발하였습니다.업무 적응력을 효과적으로 높일 수 있도록 개발에 프로젝트에서 사용하는 기술 스택을 최대한 활용하였습니다.

시연을 위한 데모 화면입니다. 시나리오를 진행하기에 앞서 보상 트랜잭션에 필요한 기준 정보를 확인하겠습니다.  본 화면에서는 보상 트랜잭션 기준 정보를 다양한 기준으로 조회할 수 있고 기준 정보를 추가, 수정 및 삭제할 수도 있습니다. 

그러면 주문을 생성하기 위하여 주문 서비스를 호출하겠습니다. / 주문을 생성하면 주문은 PENDING 상태로 대기합니다. / 이어서 재고를 차감하기 위하여 물류 서비스를 호출합니다. / 재고를 차감하고 결제를 진행합니다. 결제에 성공하면 결제 서비스는 결과를 주문에 알리고 주문 서비스는 주문을 APPROVED 상태로 변경합니다.

결제 실패 상황을 확인하기 위하여 데모를 초기화하겠습니다. 앞선 상황과 마찬가지로 주문을 생성하고 / 재고를 차감합니다. 결제에 실패하면 결제 서비스는 API로 보상 트랜잭션 서비스를 호출하여 차감된 재고를 복구합니다. 그리고 주문 서비스에 결과를 알리고 주문이 CANCELLED 상태로 변경됩니다. 보상 트랜잭션 실행 이력은 다음 화면에서 확인할 수 있습니다. 조회 버튼을 누르면 실행된 보상 트랜잭션의 ID, parameter, 성공 여부 등을 조회할 수 있습니다.

### 4. 결론

마지막으로 결론입니다. 본 과제에서 개발한 API는 서비스에서 요청하는 보상 트랜잭션만을 실시간으로 처리할 수 있습니다. 그러나 API에서 요청한 보상 트랜잭션도 실패할 가능성이 있기 때문에 이에 대비하여 실패한 보상 트랜잭션을 재시도하는 배치 프로그램 또한 필요합니다. 향후에는 이러한 배치 프로그램을 개발하여 보상 트랜잭션이 실패하더라도 재시도할 수 있게 할 예정입니다.

본 과제에서 개발한 MSA 보상 트랜잭션 API를 통하여 데이터 Transaction의 일관성을 유지하기 어렵다는 MSA의 고질적인 문제점을 해결할 수 있습니다. 또한, MSA에 꼭 필요한 보상 트랜잭션 요청 프로그램을 API로 구현하여 보상 트랜잭션 요청 기능의 유지 보수가 용이해지고 각 서비스의 개발자가 Business Logic 개발에만 집중할 수 있으므로 개발 생산성을 향상 시킬 수 있습니다. 이러한 장점을 바탕으로 본 과제에서 개발한 API는 지속적이고 신속한 서비스 혁신을 통한 Time-To-Market 단축을 가능케 할 것입니다.

OJT 과제는 아무 것도 모르던 백지 상태였던 제가 업무에 대해 이해하고 업무에 필요한 기술을 쌓을 수 있는 좋은 기회였습니다. OJT 과제 수행하는 것을 도와주신 멘토 김철영님을 비롯한 많은 분들께 감사드립니다. 이상으로 OJT 과제 발표를 마치겠습니다. 들어주셔서 감사합니다.